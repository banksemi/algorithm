---
URL: https://school.programmers.co.kr/learn/courses/30/lessons/131703
문제 유형:
  - Greedy
  - Bitmask
풀이 날짜: 2025-11-20
정답 여부: 오답
틀린 이유:
  - 최적화
마지막 풀이 날짜:
---

정답 
- 첫번째 행과 열에 맞춰 뒤집기 수행, 첫번째 행을 모두 반전한 경우, 하나만 반전시킨 경우, 모두 반전시킨 경우에 대해, 첫번째 행과 열 기준으로 뒤집기를 수행 

```
"""
7:23
visited
7:40 시간 초과 (81, 100)
"""
from collections import defaultdict
def solution(beginning, target):
    
    width = len(beginning[0])
    height = len(beginning)
    visited = set()
    def get_bitmask(arr):
        result = 0
        for y in range(0, height):
            for x in range(width):
                if arr[y][x] == 1:
                    result |= (1 << (y * width + x))
        return result
    
    beginning = get_bitmask(beginning)
    target = get_bitmask(target)
    
    dp = defaultdict(set)
    dp[0].add(beginning)
    visited = set([beginning])
    if beginning == target:
        return 0
    
    def run_row(bitmask, y):
        for x in range(width):
            bitmask ^= 1 << y*width+x
        return bitmask
    
    def run_col(bitmask, x):
        for y in range(height):
            bitmask ^= 1 << y*width+x
        return bitmask
    
    cost = 10**30
    for a, b in [(0,0), (1,0), (0, 1), (1,1)]:
        count = 0
        bitmask = beginning
        if a == 1:
            bitmask = run_col(bitmask, 0)
            count += 1
        if b == 1:
            bitmask = run_row(bitmask, 0)
            count += 1
        for x in range(width):
            target_bit = 1 << 0*width+x
            if target & target_bit != bitmask & target_bit:
                bitmask = run_col(bitmask, x)
                count += 1
        for y in range(height):
            target_bit = 1 << y*width+0
            if target & target_bit != bitmask & target_bit:
                bitmask = run_row(bitmask, y)
                count += 1
        if bitmask == target:
            cost = min(cost, count)
    
    return -1 if cost== 10 ** 30 else cost
```

시간 초과 (오답)
```
"""
7:23
visited
7:40 시간 초과 (81/100)
"""
from collections import defaultdict
from functools import lru_cache
def solution(beginning, target):
    
    width = len(beginning[0])
    height = len(beginning)
    visited = set()
    def get_bitmask(arr):
        result = 0
        for y in range(0, height):
            for x in range(width):
                if arr[y][x] == 1:
                    result |= (1 << (y * width + x))
        return result
    
    beginning = get_bitmask(beginning)
    target = get_bitmask(target)
    
    dp = defaultdict(set)
    dp[0].add(beginning)
    visited = set([beginning])
    if beginning == target:
        return 0
    
    @lru_cache(maxsize=None)
    def run_row(bitmask, y):
        original_bitmask = bitmask
        same = True
        for x in range(width):
            target_bit = 1 << y*width+x
            if target & target_bit != bitmask & target_bit:
                same = False
            bitmask ^= 1 << y*width+x
        if same:
            return original_bitmask
        return bitmask
    
    @lru_cache(maxsize=None)
    def run_col(bitmask, x):
        original_bitmask = bitmask
        same = True
        for y in range(height):
            target_bit = 1 << y*width+x
            if target & target_bit != bitmask & target_bit:
                same = False
            bitmask ^= 1 << y*width+x
        if same:
            return original_bitmask
        return bitmask
    
    for i in range(10**10):
        all_cases = set()
        for current_bitmask in dp[i]:
            for y in range(height):
                all_cases.add(run_row(current_bitmask, y))
            for x in range(width):
                all_cases.add(run_col(current_bitmask, x))
        all_cases = {i for i in all_cases if i not in visited}
        if not all_cases:
            return -1
        for bitmask in all_cases:
            visited.add(bitmask)
            if bitmask == target:
                return i + 1
        dp[i+1] = all_cases
        dp[i] = None

```