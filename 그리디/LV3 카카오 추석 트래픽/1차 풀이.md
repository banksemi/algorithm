https://school.programmers.co.kr/learn/courses/30/lessons/17676

최대 트래픽(최대 구간 개수)를 구하는 문제다.
기존 문제들과 달리 '1초' 사이의 모든 구간의 합계를 구해야한다.
이 논리를 풀기 위해 투포인터 전략을 도입했다.
- i=모든 타임
	- 단 current 조작은 END만 사용
- j = i타임 기준 1초 뒤까지 반복
	- 단 current 조작은 START만 사용
이렇게하면 시작, 끝점 각각에 대해 트래픽 측정이 가능해진다.
- 특히 j 과정에서 발견된 구간이, i에서 종료될 때 1초 뒤에 반영되는 효과가 발생한다.

```
"""
3:15 시작, 3:44 종료

9월 15일 로그데이터 -> 초당 최대 처리량 계산
- 초당 처리량: 응답 완료랑 관계 없이, 임의 시간부터 1초(1000ms)간 처리하는 요청의 최대 개수

첫번째 접근
- 시작 시간(포함) - 끝나는 시간(미포함) 으로 만들기

구간을 순서대로 스캔하는데, 투포인터로 접근하기
- 1초에 포함된 케이스만 집계

이렇게하면 구간 판단이 항상 '어떤 구간이 완전히 끝나고' 실행됨.
따라서 끝나는 시간(포함)으로 만들고 구간 판단을 진행

"""
def time_str_to_int(text): # 시작 시간(포함) - 끝나는 시간(포함)
    arr = text.split(' ')
    end_time_str_arr = arr[1].split(':')
    end_time = int(end_time_str_arr[0])
    end_time = end_time * 60 + int(end_time_str_arr[1])
    end_time = end_time * 60 * 1000 + round(float(end_time_str_arr[2]) * 1000)
    duration_ms = round(float(arr[2][0:-1]) * 1000)
    return (end_time-duration_ms+1, end_time)

END = 0
START = 1
def solution(lines):
    events = []
    for i, text in enumerate(lines):
        start_time, end_time = time_str_to_int(text)
        events.append((START, start_time, i))
        events.append((END, end_time, i))
    events.sort(key=lambda x: (x[1], x[0]))

    answer = 0
    current = 0
    j = 0
    # 앞부분에서 END만 처리, 뒷부분에서 ADD만 처리
    # print(events)
    for event_type, time, _ in events:
        # 현재 시간으로부터 1초 뒤 확인
        while j != len(events) and events[j][1] < time + 1000: # TODO 확인 필요
            if events[j][0] == START:
                current += 1
            j += 1
        answer = max(answer, current)
        # END는 다음 턴에 종료되기 때문에 먼저 answer 계산
        if event_type == END:
            current -= 1
    return answer
```


혹은 아래처럼도 가능할수도?
- 근데 조금 모호함
```
"""
3:15 시작, 3:44 종료

9월 15일 로그데이터 -> 초당 최대 처리량 계산
- 초당 처리량: 응답 완료랑 관계 없이, 임의 시간부터 1초(1000ms)간 처리하는 요청의 최대 개수

첫번째 접근
- 시작 시간(포함) - 끝나는 시간(미포함) 으로 만들기

구간을 순서대로 스캔하는데, 투포인터로 접근하기
- 1초에 포함된 케이스만 집계

이렇게하면 구간 판단이 항상 '어떤 구간이 완전히 끝나고' 실행됨.
따라서 끝나는 시간(포함)으로 만들고 구간 판단을 진행

"""
def time_str_to_int(text): # 시작 시간(포함) - 끝나는 시간(포함)
    arr = text.split(' ')
    end_time_str_arr = arr[1].split(':')
    end_time = int(end_time_str_arr[0])
    end_time = end_time * 60 + int(end_time_str_arr[1])
    end_time = end_time * 60 * 1000 + round(float(end_time_str_arr[2]) * 1000)
    duration_ms = round(float(arr[2][0:-1]) * 1000)
    return (end_time-duration_ms+1, end_time+1)

END = 0
START = 1
def solution(lines):
    events = []
    for i, text in enumerate(lines):
        start_time, end_time = time_str_to_int(text)
        events.append((START, start_time, i))
        events.append((END, end_time + 999, i)) # 이 부분 모호
    events.sort(key=lambda x: (x[1], x[0]))

    answer = 0
    current = 0
    j = 0
    # 앞부분에서 END만 처리, 뒷부분에서 ADD만 처리
    print(events)
    for event_type, time, _ in events:
        if event_type == END:
            current -= 1
        else:
            current += 1
        answer = max(answer, current)
    return answer
```