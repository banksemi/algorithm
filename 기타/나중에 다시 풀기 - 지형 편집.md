https://school.programmers.co.kr/learn/courses/30/lessons/12984

최종 풀이
```
"""

3
3
3
6
6
8
"""
def solution(land, P, Q):
    levels = []
    for row in land:
        levels.extend(row)
    levels.sort()
    
    cost = 0
    current_level = levels[0]
    for i in levels:
        diff = i - current_level
        if diff > 0:
            cost += diff * Q
    answer = cost
    current_level = levels[0]
    for i, target_level in enumerate(levels):
        if current_level != target_level:
            cost += i * P * (target_level - current_level)
            cost -= (len(levels) - i) * Q * (target_level - current_level)
            current_level = target_level
            if answer is None or cost < answer:
                answer = cost
    return answer
```
이분탐색, 삼분탐색으로 해결 안된 케이스

```
"""
1차 풀이효율성 X
블럭 수정하려면 제일 위 1개 추가 or 제일 위 한개 삭제
- 게임 머니가 들어감

목표: 지형을 평탄하게

추가하려면 비용 P
제거하려면 비용 Q

최소 비용 리턴

N: 크기: 1~300
land: 각 칸에 있는 블록의 수 (0 이상 10억 이하)

문제 바꿔보기
- n의 비용으로 평탄화가 가능한가?
    - 높이 n일 때 
    
문제 바꿔보기
- 높이 n으로 나오는 비용
- 수렴하는 지점을 찾자.

lru_cache
def bsearch(min_i, max_i)
    bsearch(min_i, m)
    bsearch(m+1, max_i)
    두개 중 최소 사용
"""
from functools import lru_cache
def solution(land, P, Q):
    levels = []
    for row in land:
        levels.extend(row)
    def get_cost(target_level):
        cost = 0
        for i in levels:
            diff = target_level - i
            # 양수면 쌓아야함
            if diff > 0:
                cost += diff * P
            elif diff < 0:
                cost += diff * -1 * Q
        return cost
    @lru_cache(maxsize=None)
    def bsearch(min_i, max_i):
        m = (min_i + max_i) // 2
        
        if min_i == max_i:
            return get_cost(min_i)
        min_i_cost = get_cost(min_i)
        m_cost = get_cost(m)
        max_i_cost = get_cost(max_i)
        
        # 일방향으로 이어진 경우, 큰 구간은 찾을 필요가 없음 (비용 그래프는 2차원 그래프이므로)
        if min_i_cost <= m_cost and m_cost <= max_i_cost:
            return bsearch(min_i, m)
        if min_i_cost >= m_cost and m_cost >= max_i_cost:
            return bsearch(m+1, max_i)
        else:
            return min(bsearch(min_i, m), bsearch(m+1, max_i))
    
    return bsearch(0, 1_000_000_001)


from functools import lru_cache
def solution(land, P, Q):
    levels = []
    for row in land:
        levels.extend(row)
    def get_cost(target_level):
        cost = 0
        p = 0
        q = 0
        for i in levels:
            diff = target_level - i
            # 양수면 쌓아야함
            if diff > 0:
                p += diff
            elif diff < 0:
                q += diff * -1
        return p * P + q * Q
    def bsearch(min_i, max_i):
        if max_i - min_i < 3:
            return min(get_cost(min_i), get_cost(min_i+1), get_cost(min_i+2), get_cost(max_i))
        gap = max_i - min_i
        m1 = min_i + gap // 3
        m2 = min_i + gap // 3 * 2
        
        m1_cost = get_cost(m1)
        m2_cost = get_cost(m2)
        if m1_cost < m2_cost:
            return bsearch(min_i, m2)
        elif m1_cost == m2_cost:
            return bsearch(m1, m2+1)
        else:
            return bsearch(m1+1, max_i)
    
    return bsearch(min(levels), max(levels) + 1)
```