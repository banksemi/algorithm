[틀림] 

이분 매칭 알고리즘을 공부하고 풀어보려고 했는데 막상 코드로 구현이 잘 되지 않았다.

이 문제를 풀면서 가장 헷갈렸던 부분
- 백트래킹처럼 dfs 하나가 끝날 때 visited에서 제외하지 않고, 최종 DFS가 끝났을 때만 초기화한다. 하나가 끝났을 때 visited를 비활성화하면 무한 루프는 아니지만 시간 초과가 발생한다.
	- 이 부분은 약간 캐싱이랑 비슷하다.
	- '실패'로 확인된 visited 케이스에서는 동일한 연산을 다시 수행하지 않는다. 즉 재귀 함수에 따라 visited 생명 주기를 관리하면, 동일한 함수를 여러 번 실행하게 된다.
- 이미 방문하거나 확인했던 노드도 다음 차례에 다시 처음부터 확인한다.
	- room 자체는 항상 차있는게 맞다. (누군가 양보를 요청하고 들어오더라도 자리는 유지되기 때문)
	- 그러나 room을 차지하고 있던 노드(소)가 바뀌는 경우 새로운 경로가 생길 수 있다.
	- 따라서 처음부터 다시 확인할 필요가 있다.

완전 탐색 방법보다 효율적인 이유
- 매칭이 불가능할때만 E(모든 간선 수)를 다시 조사한다. (이 과정을 N번 반복) 
	- 방문한 노드는 다시 방문하지 않기 때문에 가능
- 완전 탐색의 시간 복잡도는 N \*\* (M)


```
from collections import defaultdict, deque  
n, m = map(int, input().split())  
array = []  
for i in range(n):  
    array.append(list(map(int, input().split())))  
  
edges = defaultdict(list)  
for i, data in enumerate(array):  
    for next_node in data[1:]:  
        edges[i].append(next_node)  
  
mapped = {}  
# 축사 -> 소  
  
visited = set()  
def dfs(i, current_room=None):  
    if i in visited:  
        return  
    visited.add(i)  
    for want in edges[i]:  
        # 이미 가득차있으면  
        if want in mapped:  
            dfs(mapped[want], want)  
  
        # 양보 받았으면  
        if want not in mapped:  
            if current_room is not None:  
                del mapped[current_room]  
            mapped[want] = i  
            break  
  
for i in range(n):  
    visited = set()  
    dfs(i)  
print(len(mapped))
```