[틀림] https://school.programmers.co.kr/learn/courses/30/lessons/258705

타일을 왼쪽부터 순서대로 보면서 가짓수를 더해가면 구할 수 있는 문제라고 생각했다.
DP 문제, 이전 타일과 연관성은 금방 파악이 되었지만, 막상 점화식(코드)로 구현하는데 약 20분정도 소요되었다.

히든 테스트케이스에서 높은 메모리 사용량과 함께, 한 문제에 대해 시간 초과가 발생했다.

[틀린 부분] 이 부분은 스스로 생각이 안나서 질문하기란을 확인해봤는데 ( % 10007)을 통해 미리 값이 커지지 않도록 관리해야한다고 한다.


```
"""
04:45 시작
05:09 95.3점 (1 문제, 시간 초과)
DP 문제

"""
def solution(n, tops):
    def has_head(i):
        if i % 2 == 0:
            return False # 헤드가 없음
        d = i // 2
        if tops[i // 2] == 1:
            return True
        return False

    
    # DP[i] = I까지 모든 경우를 칠했을 때 나올 수 있는 가지수
    dp = {}
    dp[-1] = 1
    dp[0] = 1
    dp = [1] * (2*n+1)
    
    for i in range(1, 2*n+1):
        dp[i] = 0
        
        # 안칠하는 경우 (그대로 확장)
        dp[i] = dp[i-1]
        
        # 칠하는 경우
        
        # head를 칠하는 케이스는 이전과 관련이 없다.
        if has_head(i):
            dp[i] += dp[i-1]
        
        # head를 칠하지 않는 케이스는, 이전 타일이 칠해지지 않아야한다.
        # dp[i-2]을 통해 'i-1를 칠하지 않은 경우 발생하는 가짓수'를 활용한다.
        dp[i] += dp[i-2] % 10007
            
    return dp[2 * n] % 10007
```