https://school.programmers.co.kr/learn/courses/30/lessons/42892

[1차 재귀 함수 런타임 에러] `sys.setrecursionlimit(1_000_000_000)` 잊지 말자!
[후위 탐색] 내가 후위 탐색이 기억나지 않아 복잡한 알고리즘으로 풀었다.
- 내 알고리즘: 리프노드 찾은 후 바텀 업 방식으로 부모 노드 접근, 부모 노드의 차수가 1 이상 남아있으면 다음 리프노드로 이동.
- 원래 방식: DFS 로 탐색하는데 부모 노드를 마지막에 등록.


```
import sys
sys.setrecursionlimit(1_000_000_000)
def solution(nodeinfo): # [x축 좌표, y축 좌표] i+1번 노드
    temp = []
    for i, xy in enumerate(nodeinfo):
        temp.append((i+1, xy[0], xy[1]))

    nodes = {}
    for i in range(1, len(nodeinfo) + 1):
        nodes[i] = []
    
    def make_nodes(parent, temp):
        # parent 기준으로 좌 우 나누기
        left_temp = []
        right_temp = []
        left_head = None
        right_head = None
        
        for ixy in temp:
            if ixy[1] < parent[1]:
                left_temp.append(ixy)
                if left_head is None or left_head[2] < ixy[2]:
                    left_head = ixy
            elif ixy[1] > parent[1]:
                right_temp.append(ixy)
                if right_head is None or right_head[2] < ixy[2]:
                    right_head = ixy

        if left_head:
            nodes[parent[0]].append(left_head[0])
            make_nodes(left_head, left_temp)
            
        if right_head:
            nodes[parent[0]].append(right_head[0])
            make_nodes(right_head, right_temp)

    head_node = sorted(temp, key=lambda node: -node[2])[0]
    head_node_i = head_node[0]
    make_nodes(head_node, sorted(temp, key=lambda node: node[1]))
    
    preorder_result = []
    postorder_result = []
    
    def preorder(node):
        preorder_result.append(node)
        for i in nodes[node]:
            preorder(i)
    
    def postorder(node):
        for i in nodes[node]:
            postorder(i)
        postorder_result.append(node)
        
    preorder(head_node_i)
    postorder(head_node_i)
    return [preorder_result, postorder_result]
```


--- 과거 코드 ---

```
import sys
sys.setrecursionlimit(1_000_000_000)
def solution(nodeinfo): # [x축 좌표, y축 좌표] i+1번 노드
    temp = []
    node_to_xy = {}
    for i, xy in enumerate(nodeinfo):
        temp.append((i+1, xy[0], xy[1]))
        node_to_xy[i+1] = (xy[0], xy[1])

    nodes = {}
    parents = {}
    for i in range(1, len(nodeinfo) + 1):
        nodes[i] = []
    
    def make_nodes(parent, temp):
        # parent 기준으로 좌 우 나누기
        left_temp = []
        right_temp = []
        left_head = None
        right_head = None
        
        for ixy in temp:
            if ixy[1] < parent[1]:
                left_temp.append(ixy)
                if left_head is None or left_head[2] < ixy[2]:
                    left_head = ixy
            elif ixy[1] > parent[1]:
                right_temp.append(ixy)
                if right_head is None or right_head[2] < ixy[2]:
                    right_head = ixy

        if left_head:
            nodes[parent[0]].append(left_head[0])
            parents[left_head[0]] = parent[0]
            make_nodes(left_head, left_temp)
            
        if right_head:
            nodes[parent[0]].append(right_head[0])
            parents[right_head[0]] = parent[0]
            make_nodes(right_head, right_temp)

    head_node = sorted(temp, key=lambda node: -node[2])[0]
    head_node_i = head_node[0]
    make_nodes(head_node, sorted(temp, key=lambda node: node[1]))
    
    preorder_result = []
    postorder_result = []
    
    def preorder(node):
        preorder_result.append(node)
        for i in nodes[node]:
            preorder(i)
    
    preorder(head_node_i)
    leaf_nodes = []
    for i, childs in nodes.items():
        if not childs:
            leaf_nodes.append(i)
    
    leaf_nodes.sort(key=lambda i: node_to_xy[i][0])
    
    for leaf in leaf_nodes:
        current = leaf
        while True:
            postorder_result.append(current)
            parent = parents[current] if current in parents else None
            
            if parent is not None:
                nodes[parent].remove(current)
            
            if parent is not None and len(nodes[parent]) == 0:
                current = parent
            else:
                break

    return [preorder_result, postorder_result]
```


```
정확성  테스트

|   |   |
|---|---|
|테스트 1 〉|통과 (0.04ms, 9.32MB)|
|테스트 2 〉|통과 (0.06ms, 9.29MB)|
|테스트 3 〉|통과 (0.02ms, 9.21MB)|
|테스트 4 〉|통과 (0.02ms, 9.32MB)|
|테스트 5 〉|통과 (0.03ms, 9.21MB)|
|테스트 6 〉|통과 (123.70ms, 14.7MB)|
|테스트 7 〉|통과 (149.34ms, 14.8MB)|
|테스트 8 〉|통과 (99.80ms, 11.7MB)|
|테스트 9 〉|통과 (313.36ms, 19.7MB)|
|테스트 10 〉|통과 (17.89ms, 10.4MB)|
|테스트 11 〉|통과 (288.10ms, 18MB)|
|테스트 12 〉|통과 (361.62ms, 18.6MB)|
|테스트 13 〉|통과 (0.76ms, 9.25MB)|
|테스트 14 〉|통과 (3.61ms, 9.84MB)|
|테스트 15 〉|통과 (18.27ms, 11.8MB)|
|테스트 16 〉|통과 (45.92ms, 14.6MB)|
|테스트 17 〉|통과 (4.70ms, 9.79MB)|
|테스트 18 〉|통과 (60.77ms, 14.6MB)|
|테스트 19 〉|통과 (9.89ms, 10.3MB)|
|테스트 20 〉|통과 (20.25ms, 11.5MB)|
|테스트 21 〉|통과 (26.75ms, 12.4MB)|
|테스트 22 〉|통과 (53.39ms, 14.5MB)|
|테스트 23 〉|통과 (49.77ms, 14.7MB)|
|테스트 24 〉|통과 (0.02ms, 9.29MB)|
|테스트 25 〉|통과 (0.04ms, 9.21MB)|
|테스트 26 〉|통과 (176.50ms, 14.4MB)|
|테스트 27 〉|통과 (0.03ms, 9.26MB)|
|테스트 28 〉|통과 (0.09ms, 9.34MB)|
|테스트 29 〉|통과 (0.02ms, 9.34MB)|
```