https://school.programmers.co.kr/learn/courses/30/lessons/42892
10/25 다시 풀기
가능한 후보 그룹을 복사하지 않고 min_x, x, max_x 파라미터를 전달하여 직접 탐색하도록 했다.
그룹의 복사가 적어지므로 이전 풀이보다 성능이 좋아질 거라고 생각했지만, 조금 더 느린 결과가 나왔다.
- 이전에는 후보군이 레벨을 내려갈수록 반절씩 나뉘기 때문에 더 효율적이라면, 이번 코드는 하위 같은 레벨에 노드가 많아질수록 더 많은 탐색이 발생하여 성능 저하가 있었던 것 같다.


```
"""
8:34 시작, 8:56 종료

같은 레벨의 노드는 같은 y
- level_to_y = {} # 0,1,2,...
nodes[level] = {(node_id, x)} # x 순서로 정렬되어있음

루트 노드 찾기 (level_to_y)

# 노드 그리기
def dfs(x, min_x, max_x):
    ... # 필요하면 bsearch 


# 전위 순회, 후위 순회 결과 반환
"""
import sys
sys.setrecursionlimit(2**30)
from collections import defaultdict

def solution(nodeinfo):
    all_y = sorted(set([i[1] for i in nodeinfo]), reverse=True)
    y_to_level = {value: i for i, value in enumerate(all_y)}
    
    nodes = defaultdict(list)
    for i, node in enumerate(nodeinfo):
        x = node[0]
        y = node[1]
        level = y_to_level[y]
        nodes[level].append((i+1, x))
        
    for key in nodes:
        nodes[key].sort(key=lambda x: x[1])
    
    tree = defaultdict(list)
    def dfs(node, level, min_x, x, max_x):
        for new_node, new_x in nodes[level]:
            if min_x <= new_x and new_x <= max_x: # TODO
                tree[node].append((new_node, x))
                if new_x < x:
                    dfs(new_node, level+1, min_x, new_x, x)
                else:
                    dfs(new_node, level+1, x, new_x, max_x)
        
    dfs(nodes[0][0][0], 1, 0, nodes[0][0][1], 100000)
    
    for key in nodes:
        tree[key].sort(key=lambda x: x[1])
    
    answer = [[], []]
    def make_order(node):
        answer[0].append(node)
        for child, _ in tree[node]:
            make_order(child)
        answer[1].append(node)
        
    make_order(nodes[0][0][0])
    return answer
```

```
정확성  테스트

|   |   |
|---|---|
|테스트 1 〉|통과 (0.03ms, 9.34MB)|
|테스트 2 〉|통과 (0.04ms, 9.13MB)|
|테스트 3 〉|통과 (0.02ms, 9.3MB)|
|테스트 4 〉|통과 (0.02ms, 9.27MB)|
|테스트 5 〉|통과 (0.02ms, 9.34MB)|
|테스트 6 〉|통과 (3.27ms, 11.1MB)|
|테스트 7 〉|통과 (3.28ms, 11.1MB)|
|테스트 8 〉|통과 (11.38ms, 11.6MB)|
|테스트 9 〉|통과 (33.38ms, 15.8MB)|
|테스트 10 〉|통과 (4.68ms, 10.2MB)|
|테스트 11 〉|통과 (45.11ms, 15.7MB)|
|테스트 12 〉|통과 (41.33ms, 15.7MB)|
|테스트 13 〉|통과 (0.43ms, 9.23MB)|
|테스트 14 〉|통과 (10.66ms, 9.88MB)|
|테스트 15 〉|통과 (192.85ms, 12.3MB)|
|테스트 16 〉|통과 (1066.59ms, 15.2MB)|
|테스트 17 〉|통과 (5.27ms, 9.94MB)|
|테스트 18 〉|통과 (358.64ms, 15.3MB)|
|테스트 19 〉|통과 (13.43ms, 10.2MB)|
|테스트 20 〉|통과 (72.29ms, 11.9MB)|
|테스트 21 〉|통과 (112.85ms, 13MB)|
|테스트 22 〉|통과 (356.13ms, 15MB)|
|테스트 23 〉|통과 (342.48ms, 15.4MB)|
|테스트 24 〉|통과 (0.03ms, 9.22MB)|
|테스트 25 〉|통과 (0.04ms, 9.21MB)|
|테스트 26 〉|통과 (4.85ms, 11.2MB)|
|테스트 27 〉|통과 (0.04ms, 9.24MB)|
|테스트 28 〉|통과 (0.07ms, 9.25MB)|
|테스트 29 〉|통과 (0.01ms, 9.23MB)|
```