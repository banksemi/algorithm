10/18 다시 풀기 - https://school.programmers.co.kr/learn/courses/30/lessons/150364
아직 풀이를 떠올리는 과정이 자연스럽지 않아 나중에 다시 풀어볼 필요가 있다.

```
"""
07:45 시작, 8:03 종료

1. 공을 떨어뜨리는 순서는 고정이다.
2. 각 숫자별로 가능한 모든 조합을 세는 것은 시간 초과 발생 가능성이 큼.

모든 조건을 만족하기 위해서는 몇번 떨어뜨려야할까?
-> n번 공을 떨어뜨리면 문제를 해결할 수 있을까?

1,2,3 -> 3,3 + 1,2,3, 2,2,2
"""
class ImpossibleException(Exception):
    ...
from collections import defaultdict, deque
def solution(edges, target):
    nodes = defaultdict(deque)
    
    for a, b in sorted(edges):
        nodes[a].append(b)
    N = len(edges)
    counts = defaultdict(int)
    order = []
    def get_next_node(node):
        if not nodes[node]:
            return node
        
        next_node = nodes[node].popleft()
        nodes[node].append(next_node)
        
        return get_next_node(next_node)
    
    # target 원소의 합은 1 이상
    def check():
        for _i, target_value in enumerate(target):
            node = _i + 1
            count = counts[node]
            if count * 3 < target_value:
                return False
            if count > target_value:
                raise ImpossibleException()
        return True
    try:
        while not check():
            next_node = get_next_node(1)
            counts[next_node] += 1
            order.append(next_node)
    except ImpossibleException:
        return [-1]
    node_items = defaultdict(list)
    for _i, target_value in enumerate(target):
        node = _i + 1
        count = counts[node]
        # 최대한 사전순으로 배열하는데 형태는 맞춰야함
        arr = [1] * count
        target_value -= count
        for i in range(target_value):
            arr[count-1-i//2] += 1 # 틀린 부분 -> 실수로 나머지 계산
        node_items[node] = arr
    
    answer = []
    for i in order:
        answer.append(node_items[i].pop(0))
    return answer
```