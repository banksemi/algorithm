https://app.codility.com/programmers/lessons/6-sorting/number_of_disc_intersections/

문제가 원으로 표현되어있지만, 일차원 직선에서 구간으로 생각하면 이해가 더 직관적이다.

구간 시작 및 구간 종료 이벤트를 만들어서 겹치는 항목을 세어 문제를 풀 수 있다.

```
"""
J 디스크 -> 중점 (J,0), 반지름 A[J]

원반 교차 기준: 하나 이상의 포인트가 겹칠 때 (경계 포함)
교차하는 원반 쌍 개수
"""

START = 0 # 진입점 먼저 정렬한 뒤 실행
END = 1

def solution(A):
    events = []
    for j in range(0, len(A)): # J는 0부터 시작
        events.append((START, j-A[j]))
        events.append((END, j+A[j]))
    events.sort(key=lambda x: (x[1], x[0]))
    
    current = 0
    result = 0
    for event_type, position in events:
        if event_type == START:
            if current > 0: # 새로운 진입점이면, 기존꺼랑 겹치는 쌍이 생긴다.
                result += current
            current += 1
        else:
            current -= 1

    if result > 10_000_000:
        return -1
    return result
```
