[이전에 틀렸던 문제] https://app.codility.com/programmers/lessons/5-prefix_sums/min_avg_two_slice/
10/14 다시 풀기.

합의 평균이 가장 낮은 슬라이드 구간을 구하는 문제.

처음에는 투포인터로 접근하려했으나, 평균을 구해야하는 추가 조건으로 제대로 구현하기가 어려웠다.

그러던 중 배열을 두 부분으로 나눠서 더 작은 부분이 있다면, 차라리 작은 부분만 선택하는 것이 기존과 평균이 같거나, 더 나은 선택이라는 점을 확인했다.

따라서 슬라이드 크기를 2 or 3으로 고정하고, 스캔하여 정답을 찾았다.


```
"""
A: N개의 숫자가 있음. 
(P,Q) 0<=P<Q<N 은 A의 slice (=즉 최소 2개의 슬라이스가 있다)


slice (P, Q) = A[P] + A[P + 1] + ... + A[Q]
slice의 평균 = slice (P, Q) / (Q - P + 1)

평균이 최소가 되는 슬라이스의 start_position(P) 찾기

N은 10만이므로 O(n) or NlogN으로 풀어야한다.

element에 음수가 있다는 사실도 중요하다.


1,2,3,4,5

l, r을 만든다.
만약 r을 추가했을 떄 평균이 내려가면 -> 선택한다.
l을 오른쪽으로 옮겼을 때 평균이 내려가면 -> 선택한다.

l+r 구간에서 2개 이하의 요소만 가지고 있다면 항상 오른쪽으로 늘려본다.

모든 과정에서 최선의 답을 저장해서 max를 선택한다.

2개 이상을 선택해서 값이 내려가면, 그걸 선택하는게 맞다.
- 2개씩만 선택 or 3개씩만 선택
"""

def solution(A):
    N = len(A)
    def find_min_value_and_position(k=2):
        answer_value = 10 ** 30
        answer_position = None

        l = 0
        current_sum = 0
        for r in range(N):
            current_sum += A[r]
            count = r-l+1
            if count >= k:
                if count > k:
                    current_sum -= A[l]
                    l += 1

                if answer_value > current_sum:
                    answer_value = current_sum
                    answer_position = l
        return (answer_value/k, answer_position)
    return sorted([find_min_value_and_position(2), find_min_value_and_position(3)])[0][1]
```