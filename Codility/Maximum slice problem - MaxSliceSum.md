

부분 합의 최대를 구하는 문제.

부분 합을 구하면서 만약 새로 시작하는게 좋다고 생각하면 새로 시작해야한다.
- 물론 합계를 기억하는 배열
- 그리고 답으로 제안할 배열을 함께 계산하고 있다.
	- 왜냐하면 처음 새로 시작한 순간에는 이전에 더 좋은 답이 있었을 수 있기 때문이다.


```
"""
N개의 정수로 구성된 비어 있지 않은 배열 A가 주어졌습니다. 0 ≤ P ≤ Q < N인 정수 쌍 (P, Q)를 배열 A의 슬라이스라고 합니다. 슬라이스 (P, Q)의 합은 A[P] + A[P+1] + ... + A[Q]의 합입니다.

함수를 작성하세요.

def solution(A)
content_copy

N개의 정수로 구성된 배열 A가 주어졌을 때, A의 모든 슬라이스의 합 중 최대값을 반환하는 함수를 작성하세요.

예를 들어, 다음과 같은 배열 A가 주어졌을 때,

A[0] = 3 A[1] = 2 A[2] = -6 A[3] = 4 A[4] = 0
content_copy
함수는 다음과 같은 이유로 5를 반환해야 합니다.

(3, 4)는 합이 4인 A의 슬라이스입니다.
(2, 2)는 합이 -6인 A의 슬라이스입니다.
(0, 1)은 합이 5인 A의 슬라이스입니다.
A의 다른 슬라이스는 합이 (0, 1)보다 크지 않습니다.
다음 가정에 대한 효율적인 알고리즘을 작성하세요.

N은 [1..1,000,000] 범위의 정수입니다.
배열 A의 각 요소는 [-1,000,000..1,000,000] 범위의 정수입니다.
결과는 [-2,147,483,648..2,147,483,647] 범위 내의 정수입니다.
Copyright 2009–2025 by Codility Limited. 모든 권리 보유. 무단 복사, 출판 또는 공개를 금지합니다.


배열 요소 수는 1이상
P랑 Q는 동일할 수 있음.
"""
def solution(A):
    
    results = [0] * len(A)
    sums = [0] * len(A)

    results[0] = A[0]
    sums[0] = A[0]

    for i in range(1, len(A)):
        # 이어서 계산해본다.
        temp = sums[i-1] + A[i]

        # 혼자서 하는게 더 크면
        if temp < A[i]:
            sums[i] = A[i]
        else:
            sums[i] = temp

        # 일단 답을 갱신한다.
        results[i] = max(results[i-1], sums[i])

    return results[-1]
```