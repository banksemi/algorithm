https://app.codility.com/programmers/lessons/17-dynamic_programming/number_solitaire/

이전에는 테이블을 사용한 바텀업 방식으로 문제를 풀었고, 이번에는 재귀로 문제를 풀어보려 했으나, 코딜리티에서는 setrecursionlimit을 설정할 수 없기 때문에 런타임 에러가 발생했다.

Bottom-up 풀이
```
"""
0부터 N-1까지 칸이 있는데 N-1로 옮겨야한다.
1~6 숫자가 나오는 주사위를 사용하여 칸을 옮긴다.

옮기면서 밟은 칸의 합이 최대가 되도록 이동할 때, 최대 합을 반환
"""

def solution(A):
    N = len(A)
    INF = -N * 10_000  - 1
    scores = [INF] * N
    scores[0] = A[0]

    for i in range(N):
        for j in range(1, 7):
            if i+j >= N:
                break
            scores[i+j] = max(scores[i+j], scores[i] + A[i+j])
    return scores[N-1]
```

Top-down 풀이
```
"""
0부터 N-1까지 칸이 있는데 N-1로 옮겨야한다.
1~6 숫자가 나오는 주사위를 사용하여 칸을 옮긴다.

옮기면서 밟은 칸의 합이 최대가 되도록 이동할 때, 최대 합을 반환
"""
import sys
from functools import lru_cache

sys.setrecursionlimit(2**30)
def solution(A):
    N = len(A)
    @lru_cache(maxsize=None)
    def dfs(target):
        if target < 0:
            return None
        
        if target == 0:
            return A[0]
        
        result = None
        for i in range(1, 7):
            candidate = dfs(target-i)
            if candidate is not None:
                if result is None or result < candidate:
                    result = candidate
        
        return result + A[target]
    
    return dfs(N-1)
```