[틀림] https://app.codility.com/programmers/lessons/17-dynamic_programming/min_abs_sum/

이 문제는 시간을 단축시킬 수 있는 방법이 떠오르지 않아 풀지 못했던 문제다.

결론적으로 이 문제를 풀기 위한 아이디어는 다음과 같다.
- 주어진 숫자를 모두 양수로 바꾸고 두 그룹으로 나눈다. (+ -은 자유롭게 선택할 수 있기 때문)
- '한 그룹'에 속하지 않으면 다른 그룹에 속하기 때문에, 숫자를 원하는 만큼만 선택하여 합을 만드는 문제로 바꿀 수 있다.
- 중복된 숫자가 많기 때문에, counter를 사용해서 한번에 처리한다.
- dp는 단순히 가능한 케이스를 담을 뿐 아니라, '현재 실행중인' key를 몇번 더 사용할 수 있는지를 함께 나타낸다.

```
from collections import defaultdict

def solution(A):
    if not A:
        return 0

    counters = defaultdict(int)
    total_sum = 0
    
    for i in A:
        key = abs(i)
        counters[key] += 1
        total_sum += key
    
    dp = [-1] * (total_sum + 1)
    dp[0] = 0 # 틀린부분
    for key, count in counters.items():
        for i in range(len(dp)):
            if dp[i] >= 0: # 틀린 부분 > -> >=
                dp[i] = count

        for i in range(len(dp)):
            if i >= key:
                if dp[i-key] > 0:
                    dp[i] = max(dp[i], dp[i-key] - 1)

    result = 10**30
    for i, count in enumerate(dp):
        if count >= 0:
            p = i
            n = total_sum - i
            result = min(result, abs(p - n))
    return result
```