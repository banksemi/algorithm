---
URL: https://app.codility.com/programmers/lessons/17-dynamic_programming/min_abs_sum/
문제 유형:
  - DP(Bottom-up)
풀이 날짜: 2025-10-17
정답 여부: 오답
틀린 이유:
  - 시간 초과
마지막 풀이 날짜: 2025-12-08
---
2025.12.08 다시 풀기

문제에서 주어진 값의 최대 범위를 그대로 사용했을 때 시간 초과가 발생했다.
- 20_000 * 100 + 1

단순히 10초와 같은 시간 제한이 아니라 테스트 케이스마다 다른 시간 초과 조건을 사용하기 때문에 상수 시간을 줄일 수 있는 최적화도 중요한 것 같다.


```
from collections import defaultdict

def solution(A):
    counts = defaultdict(int)
    max_value = sum([abs(i) for i in A])
    for i in A:
        counts[abs(i)] += 1
    
    candidates = [0] * (max_value + 1)
    candidates[0] = 1
    
    for key, count in counts.items():
        for i in range(0, max_value + 1):
            if candidates[i] > 0:
                candidates[i] = count+1
            else:
                candidates[i] = 0
        
        for i in range(0, max_value + 1):
            if candidates[i] > 1:
                candidates[i + key] = max(candidates[i + key], candidates[i] - 1)
    
    answer = max_value
    for i in range(0, max_value + 1):
        if candidates[i] > 0:
            group1 = i
            group2 = max_value - i
            answer = min(answer, abs(group1 - group2))

    return answer
```


2025.10.17 풀이
[틀림] https://app.codility.com/programmers/lessons/17-dynamic_programming/min_abs_sum/

이 문제는 시간을 단축시킬 수 있는 방법이 떠오르지 않아 풀지 못했던 문제다.

결론적으로 이 문제를 풀기 위한 아이디어는 다음과 같다.
- 주어진 숫자를 모두 양수로 바꾸고 두 그룹으로 나눈다. (+ -은 자유롭게 선택할 수 있기 때문)
- '한 그룹'에 속하지 않으면 다른 그룹에 속하기 때문에, 숫자를 원하는 만큼만 선택하여 합을 만드는 문제로 바꿀 수 있다.
- 중복된 숫자가 많기 때문에, counter를 사용해서 한번에 처리한다.
- dp는 단순히 가능한 케이스를 담을 뿐 아니라, '현재 실행중인' key를 몇번 더 사용할 수 있는지를 함께 나타낸다.

```
from collections import defaultdict

def solution(A):
    if not A:
        return 0

    counters = defaultdict(int)
    total_sum = 0
    
    for i in A:
        key = abs(i)
        counters[key] += 1
        total_sum += key
    
    dp = [-1] * (total_sum + 1)
    dp[0] = 0 # 틀린부분
    for key, count in counters.items():
        for i in range(len(dp)):
            if dp[i] >= 0: # 틀린 부분 > -> >=
                dp[i] = count

        for i in range(len(dp)):
            if i >= key:
                if dp[i-key] > 0:
                    dp[i] = max(dp[i], dp[i-key] - 1)

    result = 10**30
    for i, count in enumerate(dp):
        if count >= 0:
            p = i
            n = total_sum - i
            result = min(result, abs(p - n))
    return result
```