
peaks를 구하고, 이제 최대 N을 찾아가야한다.
- 여기서는 N을 1부터 시작해도 문제가 풀렸지만 최적화하려면 다음과 같은 방안을 고려할 수 있다.
	- 1. 뒤에서부터 찾자. 왜냐하면 4개의 블럭으로 나누었을 때 가능하다면 -> 1, 2개의 블럭으로 나누었을 때도 항상 가능하다. (4의 약수)
	- 이런 개념으로 뒤에서부터 찾는게 조기 종료에 유리하다.
- [참고] 단순히 2개로 나눴을 때 안되면 3개로 나눠도 안된다 이런 개념보다는 위에서럼 약수 개념을 떠올려야했다.

```
"""
N개의 정수로 구성된 비어 있지 않은 배열 A가 주어졌습니다.

피크는 이웃보다 큰 배열 요소입니다. 더 정확히 말하면, 0 < P < N - 1, A[P - 1] < A[P], A[P] > A[P + 1]인 인덱스 P입니다.

예를 들어, 다음 배열 A는 다음과 같습니다.

A[0] = 1 A[1] = 2 A[2] = 3 A[3] = 4 A[4] = 3 A[5] = 4 A[6] = 1 A[7] = 2 A[8] = 3 A[9] = 4 A[10] = 6 A[11] = 2
content_copy
피크는 정확히 3, 5, 10입니다.

이 배열을 같은 개수의 요소를 포함하는 블록으로 나누고 싶습니다. 더 정확하게는, 다음 블록들을 생성하는 숫자 K를 선택하고자 합니다.

A[0], A[1], ..., A[K - 1],
A[K], A[K + 1], ..., A[2K - 1],
...
A[N - K], A[N - K + 1], ..., A[N - 1].
더욱이, 모든 블록은 적어도 하나의 피크를 포함해야 합니다. 블록의 극단 요소(예: A[K - 1] 또는 A[K])도 피크가 될 수 있지만, 두 이웃(인접 블록에 있는 것 포함)이 모두 있는 경우에만 가능합니다.

목표는 배열 A를 나눌 수 있는 최대 블록 개수를 찾는 것입니다.

배열 A는 다음과 같이 블록으로 나눌 수 있습니다.

한 블록(1, 2, 3, 4, 3, 4, 1, 2, 3, 4, 6, 2). 이 블록에는 세 개의 피크가 있습니다.
두 개의 블록 (1, 2, 3, 4, 3, 4)와 (1, 2, 3, 4, 6, 2). 모든 블록에는 피크가 있습니다.
세 개의 블록 (1, 2, 3, 4), (3, 4, 1, 2), (3, 4, 6, 2). 모든 블록에는 피크가 있습니다. 특히 첫 번째 블록 (1, 2, 3, 4)는 A[3]에 피크가 있는데, A[2] < A[3] > A[4]이기 때문입니다. A[4]는 인접 블록에 있습니다.
그러나 배열 A는 (1, 2, 3), (4, 3, 4), (1, 2, 3) 및 (4, 6, 2)의 네 블록으로 나눌 수 없습니다. (1, 2, 3) 블록에는 피크가 없기 때문입니다. 특히 (4, 3, 4) 블록에는 A[3]과 A[5]라는 두 개의 피크가 있습니다.

배열 A를 나눌 수 있는 최대 블록 수는 3입니다.

다음 함수를 작성하세요.

def solution(A)
content_copy

N개의 정수로 구성된 비어 있지 않은 배열 A가 주어졌을 때, A를 나눌 수 있는 최대 블록 수를 반환하는 함수입니다.

A를 특정 개수의 블록으로 나눌 수 없는 경우, 함수는 0을 반환해야 합니다.

예를 들어, 다음과 같습니다.

A[0] = 1 A[1] = 2 A[2] = 3 A[3] = 4 A[4] = 3 A[5] = 4 A[6] = 1 A[7] = 2 A[8] = 3 A[9] = 4 A[10] = 6 A[11] = 2
content_copy
위에서 설명한 대로 함수는 3을 반환해야 합니다.

다음 가정에 대한 효율적인 알고리즘을 작성하세요.

N은 [1..100,000] 범위의 정수입니다.
배열 A의 각 요소는 [0..1,000,000,000] 범위의 정수입니다.
Copyright 2009–2025 by Codility Limited. 모든 권리 보유. 무단 복사, 출판 또는 공개를 금지합니다.

"""
"""
일단 peak  찾기
그리고 정확히 나눠지는지 확인 K로
2개로 나눴을 때 안되면 3개로 나눠도 안된다 맞나?
[ ]
"""
def solution(A):
    peaks = []
    for i in range(1, len(A) - 1):
        if A[i-1] < A[i] and A[i] > A[i+1]:
            peaks.append(i)

    # 최대로 나눌 수 있는 개수는 peaks만큼 
    result = 0
    for split_count in range(1, len(peaks)+1):
        if len(A) % split_count != 0:
            continue
        K = len(A) // split_count
        set_datas = set()
        for i in peaks:
            current_position = i // K
            set_datas.add(current_position)
        # print({"K":K, "set_datas": set_datas, 'split_count': split_count})
        if len(set_datas) == split_count:
            result = max(result, split_count)
    return result
```