[틀림] 이 문제를 이진 탐색 문제로 풀었다.

탐색 조건: 
- N개의 플래그를 모두 사용해서 봉우리를 채울 수 있는가?
- 그러면 True, True, True, False... 가 되어서 마지막 True 지점을 찾아야한다.

다만 내가 외운 공식은 반닫힘구간이다.
- 즉 'check' 함수에 성공하면 더 큰 구간을 탐색한다. m+1
	- 이 말은 최종적으로 나오는 값에서 -1을 해줘야 실제 마지막 성공 지점이라는 것을 의미한다.
- 그리고 처음 탐색할때 구간은 0에서 len(flags) + 1 이다.
	- flags를 모두 꽂는 것도 답이 될 수 있기 때문이다. 그래서 반닫힘구간에 따라 +1을 한 값을 최대 값으로 설정해야한다.

```
"""
N개의 정수로 구성된 비어 있지 않은 배열 A가 주어졌습니다.

피크 는 이웃보다 큰 배열 요소입니다. 더 정확히 말하면 0 < P < N - 1이고 A[P - 1] < A[P] > A[P + 1]인 인덱스 P입니다.

예를 들어, 다음 배열 A는 다음과 같습니다.

    A[0] = 1
    A[1] = 5
    A[2] = 3
    A[3] = 4
    A[4] = 3
    A[5] = 4
    A[6] = 1
    A[7] = 2
    A[8] = 3
    A[9] = 4
    A[10] = 6
    A[11] = 2
정확히 4개의 피크를 갖습니다: 원소 1, 3, 5, 10.

아래 그림과 같이 상대적 높이가 배열 A로 표현된 산맥으로 여행을 떠나려고 합니다. 깃발을 몇 개나 가져갈지 선택해야 합니다. 
목표는 특정 규칙에 따라 봉우리에 깃발을 최대 개수로 꽂는 것입니다.



플래그는 정점에만 설정할 수 있습니다. 게다가, 플래그를 K개 사용하면 두 플래그 사이의 거리는 K보다 크거나 같아야 합니다. 인덱스 P와 Q 사이의 거리는 절댓값 |P - Q|입니다.

예를 들어, 위의 배열 A로 표현된 산맥이 주어지고 N = 12인 경우 다음을 취하면:

플래그 2개를 피크 1과 5에 설정할 수 있습니다.
플래그는 3개이며, 피크 1, 5, 10에 설치할 수 있습니다.
플래그는 4개입니다. 피크 1, 5, 10에 플래그를 3개만 설정할 수 있습니다.
따라서 이 경우 최대 3개의 플래그를 설정할 수 있습니다.

함수를 작성하세요:

def solution(A)
content_copy

N개의 정수로 구성된 비어 있지 않은 배열 A가 주어졌을 때, 배열의 피크에 설정할 수 있는 플래그의 최대 개수를 반환합니다.

예를 들어, 다음 배열 A는 다음과 같습니다.

A[0] = 1 A[1] = 5 A[2] = 3 A[3] = 4 A[4] = 3 A[5] = 4 A[6] = 1 A[7] = 2 A[8] = 3 A[9] = 4 A[10] = 6 A[11] = 2
content_copy
위에서 설명한 대로 함수는 3을 반환해야 합니다.

다음 가정에 대한 효율적인 알고리즘을 작성하세요 .

N은 [ 1 .. 400,000 ] 범위 내의 정수입니다 .
배열 A의 각 요소는 [ 0 .. 1,000,000,000 ] 범위 내의 정수입니다 .
"""


"""
peak 위치 구하기 (1, 3, 5...)
K개의 플래그가 있으면 각 플래그 사이의 거리는 K보다 크거나 같아야함.


이진 탐색으로 N 개수 구해보기
"""
def check(peaks, N):
    """
    [0,2,2,5], N보다 크거나 같은 위치 값 구하기, min()

    주어진 N을 모두 사용할 수 있을 때 O
    주어진 N을 모두 사용할 수 없을때 X
    """
    if N == 0:
        return True

    if N == 1:
        return len(peaks)
    result = 1
    last_peek = peaks[0]
    for i in range(1, len(peaks)):
        if peaks[i] - last_peek >= N:
            result += 1
            last_peek = peaks[i]
        if result == N:
            return True

    return False

def find(peaks, min_i, max_i):
    m = (min_i + max_i) // 2
    if min_i == max_i:
        return min_i
    
    if check(peaks, m):
        # 더 큰 숫자 확인해보기
        return find(peaks, m+1, max_i)
    else:
        return find(peaks, min_i, m)
def solution(A):
    peaks = []

    for i in range(1, len(A) - 1):
        if A[i-1] < A[i] and A[i] > A[i+1]:
            peaks.append(i)

    return find(peaks, 0, len(peaks) + 1) - 1
```