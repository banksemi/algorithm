---
URL: https://app.codility.com/programmers/lessons/8-leader/equi_leader/
문제 유형:
  - 배열
풀이 날짜: 2025-10-15
정답 여부: 정답
틀린 이유:
마지막 풀이 날짜: 2025-12-08
---
2025.12.08 다시 풀기
```
from collections import defaultdict

class Leader:
    def __init__(self):
        self.max_value = None
        self.count = 0
        self.total_count = 0
        self.counts = defaultdict(int)
        self.leader = None


    def add_value(self, value):
        self.counts[value] += 1
        if self.count == 0:
            self.max_value = value
        
        if self.max_value == value:
            self.count += 1
        else:
            self.count -= 1
        self.total_count += 1
        if self.counts[self.max_value] > self.total_count / 2:
            self.leader = self.max_value
        else:
            self.leader = None

def solution(A):
    left_leaders = []
    left_leader = Leader()
    right_leaders = []
    right_leader = Leader()
    
    for i in range(0, len(A)-1):
        left_leader.add_value(A[i])
        right_leader.add_value(A[len(A)-1-i])
        left_leaders.append(left_leader.leader)
        right_leaders.append(right_leader.leader)
    
    answer = 0
    for a, b in zip(left_leaders, reversed(right_leaders)):
        if a == b and a is not None:
            answer += 1
    return answer
```

2025.10.15
[틀림] https://app.codility.com/programmers/lessons/8-leader/equi_leader/
집합을 두 부분으로 나누고 각각 leader를 구해야하는 문제다.

이전에 count를 직접 사용하는 풀이에서는, 특정 배열의 리더를 알기 위해서는 모든 요소를 스캔해야하기 때문에, 배열의 크기가 달라지는 상황에서 O(n*n)이 발생한다.

따라서 코딜리티에 나와있는 Leader 선출 알고리즘을 사용하려고 하였다.
다만 배열의 과반수를 초과하는지 체크하는 로직을 빠뜨려 감점이 있었다.
- `self.element_count[self.current_leader] > self.total_count / 2`

중간에 가장 많이 등장한 후보가 과반수를 넘지 않았을 수 있는 케이스를 고려해야할 것 같다.


```
"""
leader: 반을 초과하는 요소에 등장하는 변수
equi leader: 0 ≤ S < N - 1 일때, 0~S, S+1~N-1으로 나누었을 때 동일한 리더가 나와야함.

N=3
S=0 [0,12]
S=1까지 [01,2]

N은 10만 -> n or nlogn 까지

뒷 구간별(S) 리더를 먼저 테이블에 정리,

앞 구간 리더(S)정하면서 뒷구간이랑 비교
"""
from collections import defaultdict
class leader:
    def __init__(self):
        self.value = 0
        self.current_leader = None
        self.total_count = 0
        self.element_count = defaultdict(int)
    def add(self, element):
        self.total_count += 1
        self.element_count[element] += 1
        if self.value == 0 or self.current_leader == element:
            self.value += 1
            if self.value == 1:
                self.current_leader = element
        else:
            self.value -= 1
            if self.value == 0:
                self.current_leader = None

    def get_leader(self):
        if self.current_leader is None:
            return None
        if self.element_count[self.current_leader] > self.total_count / 2: # 놓친 부분
            return self.current_leader
        else:
            return None

def solution(A):
    N = len(A)
    # 0 ≤ S < N - 1

    back_leader = leader()
    back_leaders = {}
    for i in range(N-1, 0, -1):
        back_leader.add(A[i])
        S = i - 1
        back_leaders[S] = back_leader.get_leader()

    # back_leaders[S] 입력해서 값을 얻을 수 있음.
    answer = 0
    front_leader = leader()
    for S in range(0, N-1): # 0 ≤ S < N - 1
        front_leader.add(A[S])
        if front_leader.get_leader() is not None and front_leader.get_leader() == back_leaders[S]:
            answer += 1
    return answer
```