https://app.codility.com/programmers/lessons/4-counting_elements/max_counters/

이전에 틀렸던 문제
최악의 경우 발생할 수 있는 시간 복잡도를 먼저 계산하고 최적화 알고리즘을 구상해야한다.

M\*N이 발생할 수 있는 요소는 2가지이다.
- max value를 계산하는 로직 (-> 값을 변경할 때 미리 캐싱해둔다)
- 모든 배열에 max_value로 덮어 쓰는 로직 (-> 즉시 업데이트는 하지 않고 수정 사항이 발생할 때 업데이트를 시도한다)



```
"""
N개의 카운터 -> 시작은 0

두개의 조작이 있다.
increase(X) -> X 카운터를 1만큼 증가
max_counter -> 모든 카운터를 최대 값으로 설정

A (M개의 숫자가 있다)
if A[K] == (1<=X<=N) 이면,K번째 요청은 increase(X)
if A[K} == (N+1) 이면, K번째 요청은 max_counter

카운터 수: 1~10만
조작 수: 1~10만
-> 합치면 100억, 최적화 필요

어떤 조작을 하고있을 때 max값을 자동으로 갱신하고 있을까? max(counter) N -> 1
전부 max로 덮어 씌우는 로직도 N번 들어가는데?
-> 별도의 변수를 통해 덮어씌워진 max을 기억하고 있다가, 해당 카운터 변경 요청이 오면 그때 처리하자
"""

def solution(N, A):
    # Implement your solution here
    counters = [0] * N

    max_value = 0
    base_line = 0
    for x in A:
        if x == N + 1:
            base_line = max_value
        else:
            counters[x-1] = max(counters[x-1] + 1, base_line + 1)
            max_value = max(counters[x-1], max_value)
    return [i if i > base_line else base_line for i in counters]
```