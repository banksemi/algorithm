[틀림] https://app.codility.com/programmers/lessons/10-prime_and_composite_numbers/flags/

이전과 마찬가지로 최소 값을 구하는 문제는 "특정 값을 만족할 수 있는 확인하는 결정 문제(그리디 알고리즘)"으로 찾았다.

다만 k를 직접 변경하는 과정에서 flags간 최소 거리가 의도치 않게 변하게 되어, 문제를 틀리게 되었다. 함수 인자 값을 직접 변형하는 경우 주의하자.

여기서 조금 더 최적화를 한다면 모든 포인트에 대해 다음 peak 위치를 미리 캐싱해두고, 배열을 빠르게 스캔할 수 있을 것 같다.


```
"""
A: N개의 배열 

peak: 
- 왼쪽과 오른쪽보다 값이 큰 요소 (0<P<N-1)

최대 깃발 수

플래그는 peak(정점)에만 설치 가능, 각 플래그의 거리는 K보다 '같거나 커'야함

N: 40만


"""
import sys
sys.setrecursionlimit(2**30)

def solution(A):
    N = len(A)
    last_peak = -1
    peaks = {} # peaks[피크] = 다음 피크
    for i in range(N-2, 0, -1):
        if A[i-1] < A[i] and A[i] > A[i+1]:
            peaks[i] = last_peak
            last_peak = i
    
    def check(k):
        i = 0
        min_distance = k # 틀린 부분
        while i < N:
            if i in peaks:
                k -= 1
                i += min_distance
            else:
                i += 1
            if k == 0:
                return True
        return False
    
    def bsearch(min_i, max_i):
        m = (min_i + max_i) // 2
        if min_i == max_i:
            return min_i - 1
        m_value = check(m)
        if m_value == True:
            return bsearch(m+1, max_i)
        else:
            return bsearch(min_i, m)
    return bsearch(0, 400_001)
```