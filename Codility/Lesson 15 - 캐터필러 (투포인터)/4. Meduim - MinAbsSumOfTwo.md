https://app.codility.com/programmers/lessons/15-caterpillar_method/min_abs_sum_of_two/

두 요소의 합의 절대값이 가장 작은 케이스를 찾는 문제
- 투포인터 전략을 사용했다.
- 두 변수가 최대한 0에 가까운 지점에서 시작해서 l, r을 확장시키면서 정답을 찾는다.

다만 이렇게 풀지 않고, l, r을 0과 N-1로 설정한 다음, left<=right 조건 내에서 투포인터 이동하는 전략도 있다.


```
import sys

def solution(A):
    N = len(A)
    # 1. 배열을 오름차순으로 정렬합니다.
    A.sort()

    # 2. 두 개의 포인터를 배열의 양쪽 끝에서 시작합니다.
    left = 0
    right = N - 1

    # 3. 최소 절대값 합을 저장할 변수를 초기화합니다.
    #    (초기값은 양쪽 끝 값의 합으로 설정해도 안전합니다.)
    min_abs_sum = sys.maxsize # 또는 매우 큰 수 (e.g., 2 * 10**9 + 1)

    # 4. 두 포인터가 만날 때까지 반복합니다.
    while left <= right:
        # 현재 두 포인터가 가리키는 값의 합을 계산합니다.
        current_sum = A[left] + A[right]
        
        # 최소 절대값 합을 갱신합니다.
        min_abs_sum = min(min_abs_sum, abs(current_sum))

        # 합이 0이면 더 작은 값은 없으므로 바로 0을 반환합니다.
        if current_sum == 0:
            return 0
        
        # 어떻게 포인터를 움직일지 결정합니다.
        # 목표: 합을 0에 가깝게 만들기
        if current_sum < 0:
            # 합이 음수이면, 합을 더 크게 만들어야 합니다.
            # left를 오른쪽으로 한 칸 옮겨 더 큰 값(덜 음수인 값)을 선택합니다.
            left += 1
        else: # current_sum > 0
            # 합이 양수이면, 합을 더 작게 만들어야 합니다.
            # right를 왼쪽으로 한 칸 옮겨 더 작은 값(덜 양수인 값)을 선택합니다.
            right -= 1
            
    return min_abs_sum
```