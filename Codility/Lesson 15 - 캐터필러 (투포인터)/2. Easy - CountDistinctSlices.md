---
URL: https://app.codility.com/programmers/lessons/15-caterpillar_method/count_distinct_slices/
문제 유형:
  - 투포인터
풀이 날짜: 2025-10-16
정답 여부: 정답
틀린 이유:
마지막 풀이 날짜: 2025-12-08
---
2025.12.08 다시 풀기
- 이전에는 r을 늘릴 수 있는 경우에만 늘렸다. 이번에는 r을 한칸씩 옮기고, while을 통해 unique한 값을 만들 수 있는 l을 찾는 방식으로 개선

```
def solution(M, A):
    values = set()
    duplicated = {}
    
    def add_value(value):
        if value not in values:
            values.add(value)
            return
        # 이미 values에 있는 경우
        if value not in duplicated:
            duplicated[value] = 1
        else:
            duplicated[value] += 1
    
    def remove_value(value):
        if value in duplicated:
            duplicated[value] -= 1
            if duplicated[value] == 0:
                del duplicated[value]
            return
        if value in values:
            values.remove(value)
        
    def check_unique():
        return not duplicated

    answer = 0
    l = 0
    for r in range(len(A)):
        add_value(A[r])
        while not check_unique():
            remove_value(A[l])
            l += 1
        answer += r - l + 1

    if answer > 1_000_000_000:
        return 1_000_000_000
    return answer
```
https://app.codility.com/programmers/lessons/15-caterpillar_method/count_distinct_slices/

[구현 l,r 변수 업데이트가 조금 헷갈려서, 다음에 다시 풀어보면 좋을듯]
부분 배열이 고유 변수들로만 이루어진 집합 개수 찾기

```
def solution(M, A):
    l = 0
    r = 0
    answer = 0
    ones = set()
    overflow = {}

    def add(value):
        if value not in ones:
            ones.add(value)
            return
        else:
            if value in overflow:
                overflow[value] += 1
            else:
                overflow[value] = 1

    def remove(value):
        if value in overflow:
            overflow[value] -= 1
            if overflow[value] == 0:
                del overflow[value]
        else:
            ones.remove(value)
    
    while l != len(A):
        # r을 늘릴 수 있으면 늘리기
        if r != len(A) and A[r] not in ones:
            answer += 1
            add(A[r])
            r += 1
            continue
        
        # r을 늘릴 수 없었던 경우는 l을 한칸 옮기기
        remove(A[l])
        answer += r-l-1
        l += 1

    return min(answer, 1_000_000_000)
```