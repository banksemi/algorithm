https://school.programmers.co.kr/learn/courses/30/lessons/92345
10/24 Minimax 알고리즘 다시 풀기
- 각 플레이어는 최선의 선택을 한다.
- 만약 패배가 확정된 플레이어라면
	- (추가 규칙) 상대방이 승리 조건(목표)에서 가장 멀어지도록 한다.
- **이길 수 있는 경우, 반드시 이길 수 있는 최선의 전략을 선택한다.**

```
"""
9:13 시작, 9:33 완료
가정 
- 처음에 캐릭터가 있는 곳은 발판이 있다.

다른곳으로 이동하면 기존 발판이 사라진다.

승리 조건
- 움직일 차례인데, 상하좌우 모두 이동이 불가능한 경우
- 같은 발판에 있는데, 상대가 먼저 이동하여 내 캐릭터 아래에 발판이 없어지면

게임은 항상 A가 먼저 시작한다.

이길수있는 플레이어: 빠르게 승리
질 수 밖에 없는 플레이어: 최대한 오래 버티기

발판 1: 이동 가능
발판 0: 이동 불가
두 캐릭터가 움직인 횟수의 합 

A or B 누가 이길지 모른다. -> 같은 함수를 최대한 같이 써보자
"""
import sys
sys.setrecursionlimit(2**30)

dirs = ((-1, 0), (1, 0), (0, 1), (0,-1))
def solution(board, aloc, bloc):
    height = len(board)
    width = len(board[0])
    def get_tiles(y, x):
        result = []
        if board[y][x] == 0: # 현재 발판이 없으면 이동 불가
            return []
        for iy, ix in dirs:
            new_y = y + iy
            new_x = x + ix
            if new_y < 0 or new_x < 0:
                continue
            if new_y == height or new_x == width:
                continue
            if board[new_y][new_x] == 0:
                continue
                
            result.append((new_y, new_x))
        return result
    
    def game(y, x, other_y, other_x, count):
        new_positions = get_tiles(y, x)
        if not new_positions:
            return (0, 1, count) # 승리, 패배, 움직인 횟수
        
        win_cases = []
        lose_cases = []
        for new_y, new_x in new_positions:
            # 이동한다.
            board[y][x] = 0 # 이전 발판을 제거
            result = game(other_y, other_x, new_y, new_x, count+1) # 패배, 승리, 움직인 횟수
            result = (result[1], result[0], result[2]) # 내 기준으로 바꾼다.
            if result[1] == 0: # 안지는 케이스
                win_cases.append(result)
            else:
                lose_cases.append(result)
            # 복구
            board[y][x] = 1
        
        # 이길 수 있는 경우가 있다면 무조건 선택 
        if win_cases:
            win_cases.sort(key=lambda x: x[2])
            return win_cases[0]
        else:
            # 질수밖에 없으면, 오래걸리는 것 선택
            lose_cases.sort(key=lambda x: -x[2])
            return lose_cases[0]
            
            
            
    answer = game(aloc[0], aloc[1], bloc[0], bloc[1], 0)
    return answer[2]
```