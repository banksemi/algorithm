[틀린 후 답을 보고 푼 풀이] https://school.programmers.co.kr/learn/courses/30/lessons/451808

최소 최대 전략에 따라 최선의 선택을 고른다.
한 플레이어
- 최대한 정답 후보군을 줄일 수 있는 ANSWER를 반환한다.
다른 플에이어
- 앞 플레이어가 제시한 키워드에 대해, 정답 후보군에서 하나씩 '정답이었다'라고 가정하고 계산을 수행한다. 정답 후보군을 최대한 줄일 수 없는 '정답'을 선택했다고 가정하고 새로운 후보군을 전달한다.


아직도 잘 이해가 안되는 부분
1. 최적화 로직
```
        # 최적화
        candidate_results = defaultdict(set)
        for i in candidates:
            r = get_strike_and_ball(submit_answer, i)
            candidate_results[r].add(i)
```
이 부분이 생각보다 잘 안떠올랐다. 최적화가 없다면 정답후보\*\*3의 시간 복잡도가 발생하여 문제를 풀기 어려워진다.

2. MINIMAX 알고리즘을 만드는데, 한 턴만 시뮬레이션해도 괜찮은지 불확실하다.




```
from collections import defaultdict
from functools import lru_cache
def solution(n, submit):
    BASE_CODES = set()
    for i in range(1000, 10000):
        c = set([char for char in str(i)])
        if '0' in c:
            continue
        if len(c) != 4:
            continue
        BASE_CODES.add(str(i))
    
    def get_best_case(candidates):
        if len(candidates) == 1:
            return None
        best_count = None
        best_answer = None
        best_candidate = None
        for submit_answer in BASE_CODES: # 다양한 조합 중 하나를 선택해서 제시해본다.
            new_candidates = get_worst_case(candidates, submit_answer)
            if best_count is None or best_count > len(new_candidates):
                best_count = len(new_candidates)
                best_answer = submit_answer
                best_candidate = new_candidates
        return best_answer
    
    @lru_cache(maxsize=None)
    def get_strike_and_ball(submit_answer, original_answer):
        strike = 0
        ball = 0
        for i in range(4):
            if submit_answer[i] == original_answer[i]:
                strike += 1
            elif submit_answer[i] in original_answer:
                ball += 1
        return (strike, ball)
    
    def get_worst_case(candidates, submit_answer):
        if len(candidates) == 1:
            return None
        best_count = None
        best_answer = None
        best_candidate = None
        
        # 최적화
        candidate_results = defaultdict(set)
        for i in candidates:
            r = get_strike_and_ball(submit_answer, i)
            candidate_results[r].add(i)
            
        for original_answer in candidates: # 정답 후보 중에서만 하나 선택해야한다.
            target = get_strike_and_ball(submit_answer, original_answer)
            new_candidates = candidate_results[target]
            if best_count is None or best_count < len(new_candidates):
                best_count = len(new_candidates)
                best_answer = original_answer
                best_candidate = new_candidates
        return best_candidate
    
    candidates = BASE_CODES
    i = 0
    while len(candidates) != 1:
        if i == 0:
            new_keyword = '1234'
        else:
            new_keyword = get_best_case(candidates)
        temp = submit(int(new_keyword))
        result = (int(temp[0]), int(temp[3]))
        candidates = [i for i in candidates if get_strike_and_ball(new_keyword, i) == result]
        i += 1
    return int(candidates.pop())
```