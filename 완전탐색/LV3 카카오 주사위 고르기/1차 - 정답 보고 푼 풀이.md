[틀림] https://school.programmers.co.kr/learn/courses/30/lessons/258709

처음에는 모든 케이스를 비교하는 완전 탐색이라 생각했다. 그러나 단순히 6\*\*10의 시간 복잡도가 아니라, 조합 가지수와 곱해지기 때문에 시간 초과가 났다.

이 문제를 해결하는 방법은, 각 다이스 조합의 sum 경우의 수를 구하고, 두 배열을 비교하는 것이다. 
- A 배열의 요소 하나씩 꺼내서 B 배열과 비교하면 N 제곱의 시간 복잡도가 발생하고, 정렬된 배열에서 이진 탐색으로 비교하면 NLogN으로 시간을 절약할 수 있다.

공식 해설에 있는 누적 합, 투 포인터 으로 풀어볼 필요가 있다.



```
"""
주사위를 반반 가져가려고한다.
주사위에 있는 눈금은 모두 다른데 승리 확률이 높아지는 주사위 조합을 가져가려고 한다.

결과 반환 규칙
- 1부터 오름차순 반환

N = 10

"""
from itertools import combinations, product
from functools import lru_cache

def solution(dice):
    # print(6 ** 10) ->60466176 완전 탐색 가능 약간이 최적화는 필요할 수 있음
    @lru_cache(maxsize=None)
    def dice_list(indexes):
        result = []
        for arr in product(*[dice[i] for i in indexes]):
            result.append(sum(arr))
        return sorted(result)
    
    def bsearch(arr, min_i, max_i, value):
        if min_i == max_i:
            return min_i
        m = (min_i + max_i) // 2
        if arr[m] > value:
            return bsearch(arr, min_i, m, value)
        if arr[m] == value: # 같으면 왼쪽 (이긴 횟수만 생각해야하니까, 같으면 이긴 횟수에 포함하지 않음)
            return bsearch(arr, min_i, m, value)
        if arr[m] < value:
            return bsearch(arr, m+1, max_i, value)
        
    def win_count(a_result, b_result):
        count = 0
        for a in a_result:
            count += bsearch(b_result, 0, len(b_result), a)
        return count
    
    best_score = 0
    best_a = []
    for a_indexes in combinations(range(0,len(dice)), len(dice)//2):
        b_indexes = set(range(0, len(dice))) - set(a_indexes)
        a_indexes = tuple(sorted(list(a_indexes)))
        b_indexes = tuple(sorted(list(b_indexes)))

        a_score = 0
        a_result = dice_list(a_indexes)
        b_result = dice_list(b_indexes)
        a_score = win_count(a_result, b_result)
        if best_score < a_score:
            best_score = a_score
            best_a = a_indexes
        
    return [i+1 for i in sorted(best_a)]
```

```
정확성  테스트

|   |   |
|---|---|
|테스트 1 〉|통과 (0.65ms, 9.43MB)|
|테스트 2 〉|통과 (0.04ms, 9.28MB)|
|테스트 3 〉|통과 (0.04ms, 9.39MB)|
|테스트 4 〉|통과 (0.04ms, 9.36MB)|
|테스트 5 〉|통과 (0.04ms, 9.43MB)|
|테스트 6 〉|통과 (0.05ms, 9.29MB)|
|테스트 7 〉|통과 (0.37ms, 9.34MB)|
|테스트 8 〉|통과 (0.67ms, 9.21MB)|
|테스트 9 〉|통과 (0.59ms, 9.28MB)|
|테스트 10 〉|통과 (0.36ms, 9.32MB)|
|테스트 11 〉|통과 (0.38ms, 9.28MB)|
|테스트 12 〉|통과 (0.35ms, 9.27MB)|
|테스트 13 〉|통과 (9.16ms, 9.23MB)|
|테스트 14 〉|통과 (8.99ms, 9.35MB)|
|테스트 15 〉|통과 (16.11ms, 9.34MB)|
|테스트 16 〉|통과 (10.18ms, 9.34MB)|
|테스트 17 〉|통과 (9.29ms, 9.36MB)|
|테스트 18 〉|통과 (10.25ms, 9.23MB)|
|테스트 19 〉|통과 (9393.24ms, 25.3MB)|
|테스트 20 〉|통과 (8954.33ms, 25.2MB)|
|테스트 21 〉|통과 (8588.63ms, 25.1MB)|
|테스트 22 〉|통과 (9410.27ms, 53.5MB)|
|테스트 23 〉|통과 (7891.76ms, 56.5MB)|
|테스트 24 〉|통과 (7533.00ms, 36.7MB)|
|테스트 25 〉|통과 (7482.87ms, 25.3MB)|
|테스트 26 〉|통과 (7996.03ms, 45.6MB)|

채점 결과
```
약간의 최적화 (튜플 Call by value 오버헤드 줄이기)

```
"""
주사위를 반반 가져가려고한다.
주사위에 있는 눈금은 모두 다른데 승리 확률이 높아지는 주사위 조합을 가져가려고 한다.

결과 반환 규칙
- 1부터 오름차순 반환

N = 10
print(6 ** 10) ->60466176

"""
from itertools import combinations, product
from functools import lru_cache

def solution(dice):
    # print(6 ** 10) ->60466176 완전 탐색 가능 약간이 최적화는 필요할 수 있음
    @lru_cache(maxsize=None)
    def dice_list(indexes):
        result = []
        for arr in product(*[dice[i] for i in indexes]):
            result.append(sum(arr))
        return sorted(result)
    
    def bsearch(arr, min_i, max_i, value):
        if min_i == max_i:
            return min_i
        m = (min_i + max_i) // 2
        if arr[m] > value:
            return bsearch(arr, min_i, m, value)
        if arr[m] == value: # 같으면 왼쪽 (이긴 횟수만 생각해야하니까, 같으면 이긴 횟수에 포함하지 않음)
            return bsearch(arr, min_i, m, value)
        if arr[m] < value:
            return bsearch(arr, m+1, max_i, value)
        
    def win_count(a_indexes, b_indexes):
        a_result = dice_list(a_indexes)
        b_result = dice_list(b_indexes)
        count = 0
        for a in a_result:
            count += bsearch(b_result, 0, len(b_result), a)
        return count
    
    best_score = 0
    best_a = []
    for a_indexes in combinations(range(0,len(dice)), len(dice)//2):
        b_indexes = set(range(0, len(dice))) - set(a_indexes)
        a_indexes = tuple(sorted(list(a_indexes)))
        b_indexes = tuple(sorted(list(b_indexes)))

        a_score = win_count(a_indexes, b_indexes)
        if best_score < a_score:
            best_score = a_score
            best_a = a_indexes
        
    return [i+1 for i in sorted(best_a)]
```
```
|   |   |
|---|---|
|테스트 1 〉|통과 (0.64ms, 9.35MB)|
|테스트 2 〉|통과 (0.04ms, 9.32MB)|
|테스트 3 〉|통과 (0.04ms, 9.23MB)|
|테스트 4 〉|통과 (0.04ms, 9.34MB)|
|테스트 5 〉|통과 (0.04ms, 9.31MB)|
|테스트 6 〉|통과 (0.04ms, 9.34MB)|
|테스트 7 〉|통과 (0.36ms, 9.28MB)|
|테스트 8 〉|통과 (0.36ms, 9.33MB)|
|테스트 9 〉|통과 (0.38ms, 9.36MB)|
|테스트 10 〉|통과 (0.65ms, 9.31MB)|
|테스트 11 〉|통과 (0.66ms, 9.27MB)|
|테스트 12 〉|통과 (0.36ms, 9.35MB)|
|테스트 13 〉|통과 (9.02ms, 9.36MB)|
|테스트 14 〉|통과 (9.01ms, 9.23MB)|
|테스트 15 〉|통과 (9.04ms, 9.33MB)|
|테스트 16 〉|통과 (9.20ms, 9.36MB)|
|테스트 17 〉|통과 (9.07ms, 9.45MB)|
|테스트 18 〉|통과 (8.83ms, 9.45MB)|
|테스트 19 〉|통과 (7293.41ms, 25.3MB)|
|테스트 20 〉|통과 (7286.06ms, 25.3MB)|
|테스트 21 〉|통과 (7428.80ms, 25.3MB)|
|테스트 22 〉|통과 (7709.69ms, 53.5MB)|
|테스트 23 〉|통과 (7396.08ms, 56.5MB)|
|테스트 24 〉|통과 (7532.29ms, 36.5MB)|
|테스트 25 〉|통과 (7478.42ms, 25.2MB)|
|테스트 26 〉|통과 (7318.37ms, 45.5MB)|
```