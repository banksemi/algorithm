[틀림] https://school.programmers.co.kr/learn/courses/30/lessons/258709

이전 해설에서 투포인터 전략이 있다는 내용을 보고 투포인터로 구현했다.

투포인터는 N 만큼의 시간 복잡도를 가지지만, 실제로 정렬을 먼저 해야하므로 N*LogN 이다.

물론 전체적인 BigO 표기는 동일하지만 연산량 자체가 크게 줄어든다.
```
"""
주사위를 반반 가져가려고한다.
주사위에 있는 눈금은 모두 다른데 승리 확률이 높아지는 주사위 조합을 가져가려고 한다.

결과 반환 규칙
- 1부터 오름차순 반환

N = 10
print(6 ** 10) ->60466176 완전 탐색 가능 약간이 최적화는 필요할 수 있음

"""
from itertools import combinations, product
from functools import lru_cache

def solution(dice):
    # print(6 ** 10) ->60466176 완전 탐색 가능 약간이 최적화는 필요할 수 있음
    @lru_cache(maxsize=None)
    def dice_list(indexes):
        result = []
        for arr in product(*[dice[i] for i in indexes]):
            result.append(sum(arr))
        return sorted(result)
    
    def bsearch(arr, min_i, max_i, value):
        if min_i == max_i:
            return min_i
        m = (min_i + max_i) // 2
        if arr[m] > value:
            return bsearch(arr, min_i, m, value)
        if arr[m] == value: # 같으면 왼쪽 (이긴 횟수만 생각해야하니까, 같으면 이긴 횟수에 포함하지 않음)
            return bsearch(arr, min_i, m, value)
        if arr[m] < value:
            return bsearch(arr, m+1, max_i, value)
        
    def win_count(a_indexes, b_indexes):
        a_result = dice_list(a_indexes)
        b_result = dice_list(b_indexes)
        count = 0
        j = 0
        for i in range(len(a_result)):
            while j < len(b_result) and b_result[j] < a_result[i]:
                j += 1
            count += j
        return count
    
    best_score = 0
    best_a = []
    for a_indexes in combinations(range(0,len(dice)), len(dice)//2):
        b_indexes = set(range(0, len(dice))) - set(a_indexes)
        a_indexes = tuple(sorted(list(a_indexes)))
        b_indexes = tuple(sorted(list(b_indexes)))

        a_score = win_count(a_indexes, b_indexes)
        if best_score < a_score:
            best_score = a_score
            best_a = a_indexes
        
    return [i+1 for i in sorted(best_a)]
```

```
정확성  테스트

|   |   |
|---|---|
|테스트 1 〉|통과 (0.23ms, 9.29MB)|
|테스트 2 〉|통과 (0.05ms, 9.34MB)|
|테스트 3 〉|통과 (0.03ms, 9.41MB)|
|테스트 4 〉|통과 (0.05ms, 9.27MB)|
|테스트 5 〉|통과 (0.05ms, 9.31MB)|
|테스트 6 〉|통과 (0.03ms, 9.33MB)|
|테스트 7 〉|통과 (0.13ms, 9.42MB)|
|테스트 8 〉|통과 (0.24ms, 9.24MB)|
|테스트 9 〉|통과 (0.13ms, 9.32MB)|
|테스트 10 〉|통과 (0.13ms, 9.24MB)|
|테스트 11 〉|통과 (0.13ms, 9.33MB)|
|테스트 12 〉|통과 (0.13ms, 9.3MB)|
|테스트 13 〉|통과 (4.15ms, 9.36MB)|
|테스트 14 〉|통과 (3.97ms, 9.33MB)|
|테스트 15 〉|통과 (3.83ms, 9.2MB)|
|테스트 16 〉|통과 (2.07ms, 9.31MB)|
|테스트 17 〉|통과 (2.15ms, 9.32MB)|
|테스트 18 〉|통과 (2.02ms, 9.32MB)|
|테스트 19 〉|통과 (1042.86ms, 25.2MB)|
|테스트 20 〉|통과 (1165.66ms, 25.2MB)|
|테스트 21 〉|통과 (1313.37ms, 25.2MB)|
|테스트 22 〉|통과 (1176.60ms, 53.4MB)|
|테스트 23 〉|통과 (1345.44ms, 56.5MB)|
|테스트 24 〉|통과 (1163.79ms, 36.6MB)|
|테스트 25 〉|통과 (1057.86ms, 25.3MB)|
|테스트 26 〉|통과 (1101.45ms, 45.7MB)|
```