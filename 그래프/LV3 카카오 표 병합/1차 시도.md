https://school.programmers.co.kr/learn/courses/30/lessons/150366

병합 / 병합 해제를 서로소 집합으로 표현했다. 
- UNMERGE를 수행하기 위해, parents 와 별개로 childs 배열을 함께 관리했다. UNMERGE 발생시 루트 노드를 찾고 DFS 방식으로 하위 노드를 찾아가며 parents를 초기화한다.
- 특정 텍스트를 가지는 값을 일괄 변환하기 위해 set 구조로 캐싱을 추가했다.

구현 시간을 줄일 필요가 있음.

```
"""
표 크기:50*50으로 고정, 모든 셀 비어있음.

6:10 시작, 6:49 완료

테스트 코드

    commands = [
        "UPDATE 1 2 ABC",
        "UPDATE 1 3 EEE",
        "MERGE 1 2 1 3",
        "UNMERGE 1 3",
        "PRINT 1 2",
        "PRINT 1 3"
    ]
    
"""
import sys
sys.setrecursionlimit(2**30)
from collections import defaultdict
def solution(commands):
    texts = [None] * (50 * 50)
    texts_cache = defaultdict(set) #texts_cache[텍스트]=  set(노드들)
    parents = [i for i in range(2500)]
    childs = defaultdict(list)
    def get_index(r, c):
        r -= 1
        c -= 1
        return r * 50 + c
    
    def find_parent(i):
        if parents[i] == i:
            return i
        parents[i] = find_parent(parents[i])
        return parents[i]
    
    def union(i, j):
        if i == j: # 같은 경우 무시
            return
        
        i_parent = find_parent(i)
        j_parent = find_parent(j)
        if i_parent == j_parent:
            return
        
        # 둘중 한값이 있으면 그거 선택, 둘다 있으면 i 선택
        text = texts[i_parent]
        if text is None:
            text = texts[j_parent]
            
        update_rc_value(i_parent, text)
        update_rc_value(j_parent, None)
        parents[j_parent] = i_parent
        childs[i_parent].append(j_parent)
    
    def unmerge(i):
        parent_i = find_parent(i)
        
        def dfs(node):
            parents[node] = node
            update_rc_value(node, None)
            for j in childs[node]:
                dfs(j)
            childs[node] = list()
        text = print_text(i)
        dfs(parent_i)
        update_rc_value(i, text)
        
        
    def update_rc_value(i, value):
        parent_i = find_parent(i)
        original_text = texts[parent_i]
        if original_text is not None:
            texts_cache[original_text].remove(parent_i)
            texts[parent_i] = None
        texts_cache[value].add(parent_i)
        texts[parent_i] = value
    
    def update_text_to_value(text, value):
        if text == value:
            return
        for i in texts_cache[text].copy():
            texts[i] = value
            texts_cache[value].add(i)
        texts_cache[text] = set()
        
    def print_text(i):
        parent_i = find_parent(i)
        return texts[parent_i]
    answer = []
    for text in commands:
        arr = text.split(' ')
        command = arr[0]
        
        if arr[0] == 'UPDATE':
            if len(arr) == 4:
                i = get_index(int(arr[1]), int(arr[2]))
                update_rc_value(i, arr[3])
            if len(arr) == 3:
                update_text_to_value(arr[1], arr[2])
        if arr[0] == 'MERGE':
            i = get_index(int(arr[1]), int(arr[2]))
            j = get_index(int(arr[3]), int(arr[4]))
            union(i, j)
            
        if arr[0] == 'UNMERGE':
            i = get_index(int(arr[1]), int(arr[2]))
            unmerge(i)
        if arr[0] == 'PRINT':
            i = get_index(int(arr[1]), int(arr[2]))
            answer.append(print_text(i))

    return [i if i is not None else 'EMPTY' for i in answer]

```

```
|   |   |
|---|---|
|테스트 1 〉|통과 (0.17ms, 9.74MB)|
|테스트 2 〉|통과 (0.23ms, 9.42MB)|
|테스트 3 〉|통과 (0.13ms, 9.45MB)|
|테스트 4 〉|통과 (0.10ms, 9.46MB)|
|테스트 5 〉|통과 (0.12ms, 9.54MB)|
|테스트 6 〉|통과 (0.14ms, 9.43MB)|
|테스트 7 〉|통과 (0.15ms, 9.41MB)|
|테스트 8 〉|통과 (0.15ms, 9.39MB)|
|테스트 9 〉|통과 (0.27ms, 9.49MB)|
|테스트 10 〉|통과 (0.26ms, 9.65MB)|
|테스트 11 〉|통과 (0.41ms, 9.65MB)|
|테스트 12 〉|통과 (0.27ms, 9.69MB)|
|테스트 13 〉|통과 (1.99ms, 9.63MB)|
|테스트 14 〉|통과 (3.79ms, 9.73MB)|
|테스트 15 〉|통과 (2.51ms, 9.78MB)|
|테스트 16 〉|통과 (2.19ms, 9.71MB)|
|테스트 17 〉|통과 (2.31ms, 9.72MB)|
|테스트 18 〉|통과 (4.02ms, 9.69MB)|
|테스트 19 〉|통과 (1.57ms, 9.54MB)|
|테스트 20 〉|통과 (3.53ms, 9.64MB)|
|테스트 21 〉|통과 (2.52ms, 9.61MB)|
|테스트 22 〉|통과 (2.37ms, 9.66MB)|
```