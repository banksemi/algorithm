[효율성에서 일부 틀림] https://school.programmers.co.kr/learn/courses/30/lessons/64063

처음에는 원하는 방 번호를 기준으로 정렬하고 마지막에 추가한 룸 번호 기억하면서 순서대로 배정하려고 했다.

다만 이 경우 먼저 온 손님을 고려하지 못했기 때문에 다른 방안을 찾았다.

그러던 중 서로소 집합을 응용할 방법이 떠올랐다.
- 모든 방은 다음 방을 가르키고 있고, 만약 방에 들어가지 못하면 다음 방으로 이동하도록 한다.
- 그리고 다음 방을 찾을 때 경로 단축을 사용하도록 했다.
- [추가 최적화 포인트] K는 10의 12승
	- 사용 가능한 방 목록 -> 이미 사용중인 방 목록
	- 다음 노드 배열 -> N+1을 가르킬 때에는 defaultdict으로 처리
- [틀린 부분] 경로 단축을 할 때 시작점만 단축시켰는데, 중간에 방문했던 방들도 함께 단축시켜줘야했다. 원래 경로 단축을 재귀함수로 만들면 자연스럽게 모든 방문 노드의 경로 단축이 이루어지지만, 직접 반복문을 사용하다보니 이 부분을 놓치게 되었다.
- 

```
"""
방 개수: K

1. 한명씩
2. 원하는 방 번호
3. 비어있으면 즉시, 아니면, 번호가 더 크면서 비어있는 방 중 가장 번호가 작은거

# 미리 다음 방 번호를 지정하고 있어야함.
정렬하고 순서대로?
--- 

링크드 리스트로 연결된 방
- 새로운 요청이 들어오면 들어갈 방을 오른쪽 링크로 찾고, 경로 단축

이 과정을 통해 n번 반복으로 빠르게 완료할 수 있다.
"""

from collections import defaultdict
def solution(k, room_number):
    answer = []
    used_room = set()
    next_rooms = defaultdict(lambda: -1)
    
    for start_room in room_number:
        room = start_room
        visited_rooms = set()
        while room in used_room:
            visited_rooms.add(room)
            if next_rooms[room] == -1:
                room = room + 1
            else:
                room = next_rooms[room]
        # 경로 단축
        for i in visited_rooms:
            next_rooms[i] = room+1
        used_room.add(room)
        answer.append(room)
        
    return answer
            
```