https://school.programmers.co.kr/learn/courses/30/lessons/72413

N=200이므로 N\*\*3의 시간 복잡도를 가지는 플로이드 워셜 알고리즘을 사용할 수 있다.

```
from collections import defaultdict

INF = 10**30
def solution(n, s, a, b, fares):
    # 플로이드 워셜 알고리즘
    distances = defaultdict(lambda: defaultdict(lambda: INF))
    for c, d, cost in fares:
        distances[c][d] = cost
        distances[d][c] = cost
        
    for k in range(1, n+1): # 중요: 같은 지점으로 이동시에는 비용이 없음
        distances[k][k] = 0
        
    for k in range(1, n+1):
        for i in range(1, n+1):
            for j in range(1, n+1):
                # i->j로 이동하는데 k를 경유
                distances[i][j] = min(distances[i][j], distances[i][k] + distances[k][j])
                
    answer = INF
    for k in range(1, n+1):
        # k까지 함께 이동
        answer = min(answer, distances[s][k] + distances[k][a] + distances[k][b])

    return answer
```