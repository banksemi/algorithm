[틀림] https://school.programmers.co.kr/learn/courses/30/lessons/21429

주어진 간선 중 하나의 코스트가 변할 때 최적의 시간이 변하는 경우를 찾는 문제다.
- n은 5만개 이하, 간선은 20만개 이하

처음 내 생각
- 다익스트라에서 key를 (node, 변경된엣지) 처럼 상태를 함께 기록하여, 최적의 경로를 찾아가는 중 특정 간선의 트래픽이 변하는 상태를 key에 함께 표현했다.
- 사실상 다익스트라를 엣지의 개수(20만개)를 반복하게 되어 시간 초과를 받게 된다.

이 상황에서 https://school.programmers.co.kr/questions/53827 을 보고 힌트를 받아가면서 문제를 이해해서 풀고자 함.

엣지의 트래픽이 감소하는 케이스
- 엣지의 트래픽이 감소하는 케이스는 아래처럼 나타낼 수 있다.
- 출발지 - 어떤 최적의 경로 - 엣지 끝점(A) - (비용 감소) - 엣지 끝점(B) - 어떤 최적의 경로 - 목적지
- 즉 A,B를 경유할 때 최하의 트래픽으로 이동이 가능해서, 도착 시간이 단축될 수 있다면 -> 해당 간선은 유의미한 간선으로 생각할 수 있다.
- 다익스트라는 일반적으로 한 지점에서 모든 지점까지의 최적 거리를 구할 수 있다.
- 반대로 생각하면(LV3 부대복귀 문제) 모든 지점에서 어떤 한 지점까지의 최적 거리를 구할 수 있다.
- 이를 통해 다익스트라를 정방향,역방향으로 수행하여 기록하고 임의의 엣지를 경유하게하여 비용이 감소되는지를 찾으면 문제가 해결된다.

엣지의 트래픽을 증가시키는 케이스
- 이 케이스는 위의 방법으로 해결이 어렵다. 트래픽이 증가되었을 때, 해당 경로를 제외한 다른 우회 경로(동일비용)가 있을 수 있기 때문이다.
- 따라서 최단 경로로 가기 위해서는 무조건 거쳐야하는 경로를 구해야한다.
- 다익스트라 알고리즘을 수행하고, 목적지에서 최적의 비용과 같은 포함하도록 BFS를 사용하면 최단 경로로 이동 가능한 모든 간선을 얻을 수 있다.
- 이를 이용하여 그래프를 재구성하고 다익스트라를 진행한다. 
	- 노드를 꺼낸 후 '처음 방문하는 노드 일 때' queue의 개수를 확인한다.
		- queue의 개수가 0개인 경우, 동일 코스트로 노드를 방문하는 경우의 수는 1개임을 의미한다.
		- queue의 개수가 1개 이상인 경우, 동일 코스트로 노드를 방문하는 경우의 수가 더 있거나, 혹은 더 나중의 노드로 이동하는 우회 케이스가 있다는 것을 의미한다.

추가
- 기존엔 다익스트라를 사용할 때 PriorityQueue를 사용했지만, heapq를 사용하면 시간 효율성이 약 2배 이상 증가하는 것을 확인했다.


```
"""
트래픽은 하나만 변한다.

탐색을 진행하면서, 최적의 엣지를 하나씩 선택한다.
- (cost, 노드, 이게 확정되었을 때 정답후보에추가되어야할내용(다른간선존재))

한개의 노드의 트래픽이 극단적 (0 or 무한)으로 바뀌는 경우 최단 경로가 어떻게 바뀌는지 찾자.
(node, stauts(이미 극단적 적용))

오답(시간초과)
-----
힌트를 보면서 진행

먼저 엣지의 트래픽이 감소하는 경우를 찾자.
트래픽 기준으로 1-N까지 최단 거리를 구한다.
간선이 (A,B)를 이을때
거리(1,A) + A_B 비용(트래픽 제거) + 거리(B,N)가 더 작아지는 경우는 최단 거리가 갱신되는 경우이다.
- 1에서 다른 노드들로 가는 최소 비용은 계산이 가능하다.
- 반대로 모든 노드들에서 N으로 가는 최소 비용은? 다익스트라를 역방향으로 수행해야한다.
- 근데 이러면 모든 노드들을 다 계산해야하니까, node==N 달성시 사전 종료를 꺼야하나? -> 꺼야한다.
- 당연히 A,B 반전되었을 때도 고려해야한다.

엣지의 트래픽이 증가하는 경우
- 이동하는 최단 경로가 증가하는 경우
- 엣지 케이스: 물론 다른 최단 경로가 존재하는 경우 트래픽 증가가 무의미할 수 있음.
- 트래픽이 증가한다는 의미는 단선을 의미함.
- 최악의 케이스 n개의 선이 일직선으로 이어짐?
- (A-B) 잇는 선분
    - 단선 찾는 법 (A-B를 쓰지 않고), B까지 도착할 수 있는 다른 경로가 있는 경우
    - =(B까지 도착할 수 있는 최단 경로 (A로부터, C로부터))를 기록해둔다.
    - 이게 있으면 트래픽이 증가했을 때 영향을 받지 않는 도로다.
    
"""
import heapq
from queue import PriorityQueue
from collections import defaultdict, deque
INF = 10 ** 30
def solution(n, roads):
    nodes = defaultdict(list)
    i = 1
    for a, b, cost, traffic in roads:
        nodes[a].append((b, cost, traffic, i))
        nodes[b].append((a, cost, traffic, i))
        
        i += 1
        
    def run(src, dst):
        queue = []
        heapq.heappush(queue, (0, src))
        
        distances = [10**30] * (n + 1)

        while queue:
            cost, node = heapq.heappop(queue)
            if cost > distances[node]:
                continue
                
            distances[node] = cost
            #if node == dst: # 런타임 에러
            #    break
            for next_node, add_cost, new_traffic, edge_no in nodes[node]:
                new_cost = cost+add_cost+new_traffic
                if distances[next_node] > new_cost:
                    distances[next_node] = new_cost
                    heapq.heappush(queue,(new_cost, next_node))
        return distances
    
    def get_started(distances, src, dst):
        started = defaultdict(list)
        original_distance = distances[dst]
        queue = deque()
        queue.append(dst)
        visited = set()
        while queue:
            current_node = queue.popleft()
            if current_node in visited:
                continue
            visited.add(current_node)
            for previous_node, add_cost, new_traffic, edge_no in nodes[current_node]:
                if distances[previous_node] + add_cost + new_traffic == distances[current_node]:
                    started[previous_node].append({
                        'node': current_node, 
                        'edge': edge_no,
                        'cost': add_cost+new_traffic
                    })
                    queue.append(previous_node)
        return started
    
    distances = run(1, n)
    distances_reversed = run(n, 1)

    original_distance = distances[n]
    i = 1
    answer = set()
    for a, b, cost, traffic in roads:
        if distances[a] + cost + distances_reversed[b] < original_distance:
            answer.add(i)
        # 당연히 역방향도 고려해야함
        if distances[b] + cost + distances_reversed[a] < original_distance:
            answer.add(i)
        i += 1
        
    started = get_started(distances, 1, n)

    # 문제 변환
    # n까지 이동할 수 있는 엣지가 주어졌을 때, 단선시 이동이 불가능한 엣지를 구한다.
    def test(started):
        queue = []
        heapq.heappush(queue, (0,1))
        visited = set()
        important_edges = set()
        froms = defaultdict(list)
        for key in started:
            for item in started[key]:
                froms[item['node']].append(item['edge'])
              
        while queue:  
            cost, node = heapq.heappop(queue)
            if node in visited:
                continue
            
            if not queue:
                if len(froms[node]) == 1:
                    for item in froms[node]:
                        important_edges.add(item)
                
            visited.add(node)
            for item in started[node]:
                next_node = item['node']
                if next_node in visited:
                    continue
                heapq.heappush(queue, (cost + item['cost'], next_node))

        # 5번에서 역순 탐색
        return important_edges
    answer |= test(started)
    if answer:
        return sorted(answer)
    else:
        return [-1]
```