[나중에 다시 풀어보기] https://school.programmers.co.kr/learn/courses/30/lessons/214293
중요한 도로 판단 기준(우회도로 없음)을 도로 경우의 수 조합을 통해 해결할 수 있는 풀이가 있어, 해당 방법으로도 구현해보게 되었다.
- 최단 거리만 사용하여 그래프를 표현했을 때, 어떤 간선 기준 왼쪽의 경우의 수 조합과 오른쪽의 경우의 수 조합이 모든 경우의 수 조합이 되는 경우, 유일한 도로로 판단할 수 있다.


```
from collections import defaultdict
import heapq
INF = 10 ** 30
def solution(n, roads):
    nodes = defaultdict(list)
    ab_to_edge_nubmer = {}
    i = 1
    for a, b, cost, traffic in roads:
        nodes[a].append((b,cost,traffic))
        nodes[b].append((a,cost,traffic))
        ab_to_edge_nubmer[(a,b)] = i
        ab_to_edge_nubmer[(b,a)] = i
        i += 1
    
    def run(src, dst):
        queue = []
        distances = defaultdict(lambda: INF)
        counts = defaultdict(int)
        counts[src] = 1
        queue.append((0, src))
        distances[src] = 0
        visited = set()
        while queue:
            cost, node = heapq.heappop(queue)
            if node in visited:
                continue
            visited.add(node)
            for next_node, new_cost, new_traffic in nodes[node]:
                total_cost = cost + new_cost + new_traffic
                if distances[next_node] > total_cost:
                    distances[next_node] = total_cost
                    counts[next_node] = counts[node]
                    heapq.heappush(queue, (total_cost, next_node))
                elif distances[next_node] == total_cost:
                    counts[next_node] += counts[node]
                    
        return distances, counts
    answer = set()
    distances, counts = run(1, n)
    reversed_distances, reversed_counts = run(n, 1)
    base_distance = distances[n]
    for i, item in enumerate(roads):
        a, b, cost, traffic = item
        if distances[a] + cost + reversed_distances[b] < base_distance:
            answer.add(i + 1)
        if distances[b] + cost + reversed_distances[a] < base_distance:
            answer.add(i + 1)
    # 중요한 도로 판단 기준: 왼쪽 노드, 오른쪽 노드 카운트 곱해서 최종 n까지의 카운트 뜨는지 확인
    
    def traffic_plus_test(distances, dst, counts, reversed_counts):
        answer = set()
        queue = []
        visited = set()
        queue.append(dst)
        while queue:
            node = queue.pop()
            if node in visited:
                continue
            visited.add(node)
            for previous_node, cost, traffic in nodes[node]:
                if distances[previous_node] + cost + traffic == distances[node]:
                    queue.append(previous_node)
                    # 최단 경로에 대해서만 진행
                    if counts[previous_node] * reversed_counts[node] == counts[dst]:
                        answer.add(ab_to_edge_nubmer[previous_node, node])
        return answer
    # 최단 거리에 사용되는 모든 도로들에 대해 진행 
    answer |= traffic_plus_test(distances, n, counts, reversed_counts)
    if answer:
        return sorted(answer)
    else:
        return [-1]
```