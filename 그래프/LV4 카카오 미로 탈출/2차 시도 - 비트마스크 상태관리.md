https://school.programmers.co.kr/learn/courses/30/lessons/81304
trap 상태 관리를 비트로 관리하는 버전으로 풀이를 변경했다.
이전 과 달리 모든 트랩 상태를 한번에 관리한다.
- 트랩 수는 10개

사실 비트 연산에서 XOR이 사용되는 시나리오에 대해 잘 와닿지 않았었는데, 이번 기회에 XOR을 활용해볼 수 있었다.
- 다른 비트들은 값을 유지하면서 특정 비트만 반전시킬 때 XOR 010000...

```
from collections import defaultdict
from queue import PriorityQueue
def solution(n, start, end, roads, traps):
    traps_set = set(traps)
    traps_index = {node: i for i, node in enumerate(traps)}
    edges = defaultdict(list)
    for a,b,cost in roads:
        edges[a].append((cost, b, True)) # True: 정방향
        edges[b].append((cost, a, False)) #False 역방향

    def change_status(trap_status, node_id):
        if node_id not in traps_set: # 트랩이 아니면 변경 불가
            return trap_status
        return trap_status ^ (1 << traps_index[node_id])
            
    def is_trap_status(trap_status, node_id):
        if node_id not in traps_set:
            return False
        return bool(trap_status & (1 << traps_index[node_id]))
        
    def get_tiles(cost, node, trap_status):
        candidate = []
        for _cost, next_node, _direct in edges[node]:
            direct = _direct
            if is_trap_status(trap_status, node):
                direct = not direct
            if is_trap_status(trap_status, next_node):
                direct = not direct
            if direct:
                candidate.append((_cost, next_node))
        
        for add_cost, next_node in candidate:
            yield cost+add_cost, next_node, change_status(trap_status, next_node)
            
    visited = set()
    queue = PriorityQueue()  # cost, node, trap_status
    queue.put((0, start, 0))
    while not queue.empty():
        cost, node, trap_status = queue.get()
        key = (node, trap_status)

        if key in visited:
            continue
        visited.add(key)
        if node == end:
            return cost
        for new_cost, new_node, new_status in get_tiles(cost, node, trap_status):
            new_key = (new_node, new_status)
            if new_key in visited:
                continue
            queue.put((new_cost, new_node, new_status))
    return -1
```