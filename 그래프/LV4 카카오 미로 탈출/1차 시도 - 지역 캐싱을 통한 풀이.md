https://school.programmers.co.kr/learn/courses/30/lessons/81304
다익스트라에 노드 상태를 함께 캐싱하는 문제다. 이 문제를 풀면서 비트마스크를 쓸 줄 알면 더 효율적으로 작성할 수 있겠다는 생각이 들었지만, 비트마스크를 사용하는 방법을 잘 몰랐기에 tuple+sorted로 상태를 표현했다. 조만간 비트 마스크를 이해하고 풀이에 적용해볼 예정이다.


풀이 방법
visited 배열에 사용할 key에 대해 함정 상태를 함께 캐싱하도록 했다.
- 함정 상태를 캐싱할 때 모든 함정 상태를 캐싱하면 범위가 넓어지므로 연관된 노드와 스스로의 상태만 사용했지만, traps 수는 10으로 제한되어있어 큰 상관은 없을 것 같다.
- 하나의 road를 두고 두 노드가 모두 함정 발동 상태가 된 경우, 다시 edge가 정방향으로 돌아오는 것을 기억하자.


```
"""
12:11 시작, 12:51 종료

화살표로만 이동 가능, 시간(cost) 존재

출발 지점에서 탈출 가능 방까지 이동해야함 (최소 시간 구하기)
함정
- 이 방으로 이동하는 순간, 함정 방과 연결된 모든 길의 방향이 반대가 된다.
- 다시 방문하면 다시 뒤집힌다. 
- 즉 여러번 방문해서 길의 방향을 반대로 뒤집을 수 있다.


함정 방에 방문하면 길의 경로가 바뀐다는걸 이용하자
- 한번 방문

풀이
다익스트라를 사용하되 함정 상태를 캐싱한다.
- '연관된 노드'의 함정 상태만 캐싱하여 캐싱 범위를 지역적으로 바꾼다.
- 캐싱 알고리즘: 연관된 노드의 함정 상태 정렬 (현재 노드 순서는 상관이 없음)(2,3)->(11)

n = 1000
"""
from collections import defaultdict
from queue import PriorityQueue
def solution(n, start, end, roads, traps):
    traps = set(traps)
    edges = defaultdict(list)
    edges_related = defaultdict(list)
    for a,b,cost in roads:
        edges[a].append((cost, b, True)) # True: 정방향
        edges[b].append((cost, a, False)) #False 역방향 
        edges_related[a].append(b)
        edges_related[b].append(a)
    
    for i in edges_related:
        edges_related[i] = sorted(edges_related[i])
        
    def get_tiles(cost, node, trap_status):
        
        candidate = []
        for _cost, next_node, _direct in edges[node]:
            direct = _direct
            if node in trap_status:
                direct = not direct
            if next_node in trap_status:
                direct = not direct
            if direct:
                candidate.append((_cost, next_node))
        
        for add_cost, next_node in candidate:
            new_trap_status = set()
            for i in edges_related:
                if i != next_node and i in trap_status:
                    new_trap_status.add(i)
            # Next Node에 대한 상태를 반전
            if next_node in traps and next_node not in trap_status:
                new_trap_status.add(next_node)
            key = tuple(sorted(new_trap_status))
            yield cost+add_cost, next_node, key
            
    visited = set()
    distances = defaultdict(lambda: 10**10)
    queue = PriorityQueue()  # cost, node, trap_status
    queue.put((0, start, ()))
    while not queue.empty():
        cost, node, trap_status = queue.get()
        key = (node, trap_status)

        if key in visited:
            continue
        visited.add(key)
        if node == end:
            return cost
        for new_cost, new_node, new_status in get_tiles(cost, node, trap_status):
            new_key = (new_node, new_status)
            if new_key in visited:
                continue
            queue.put((new_cost, new_node, new_status))
    return -1
```