[틀림] https://school.programmers.co.kr/learn/courses/30/lessons/72415
lru_cache가 누락되어 시간 초과가 발생했다. 바로 lru_cache를 적용하고 1차 시도보다 효율성을 개선하여 문제를 통과했다.

카드 방문 순서는 직접 백트래킹과 yield를 사용하여 구현했고, 카드 개수가 제한적이므로 move 함수에 카드 상태를 나타내는 비트마스크를 적용하여 캐싱이 가능한 구조로 만들었다.

비트마스크를 구현하는 과정에서 대부분의 시간이 소요되었기 때문에 이 부분을 다시 연습할 필요가 있다.

```
"""
10:38 시작, 11:14 시간 초과, 11:15 완료
카드 16장

2장 뒤집었을때 두 카드가 사라진다.

이동 옵션
- 한칸 이동 
- 해당 라인에 가장 가까운 카드 or 벽

이동, 카드 선택 조작 = 각 cost 1
"""
from collections import defaultdict, deque
from functools import lru_cache
INF = 10 ** 30
def solution(board, r, c):
    # 카드 위치 확인 
    width = height = 4
    cards = defaultdict(list)
    for y in range(height):
        for x in range(width):
            no = board[y][x]
            if no > 0:
                cards[no].append((y,x))
    
    stack = []
    def order(cards):
        # 어떤 카드를 선택할지 고름
        if not cards:
            yield stack
        for i in cards:
            for a, b in [(0, 1), (1,0)]:
                stack.append(cards[i][a])
                stack.append(cards[i][b])
                for next_stack in order({key: value for key, value in cards.items() if key != i}):
                    yield next_stack
                stack.pop()
                stack.pop()
    
    card_positions = {}
    card_index_to_yx = {}
    i = 0
    for arr in cards.values():
        for yx in arr:
            card_positions[yx] = i
            card_index_to_yx[i] = yx
            i += 1
    
    dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]
    def check(y, x):
        if y < 0 or x < 0:
            return False
        if y == height or x == width:
            return False
        return True
    
    def get_tiles(y, x, remain_cards):
        for iy, ix in dirs:
            # 1칸 이동 옵션 주기
            # 카드를 만나거나 벽까지, 중복 괜찮음
            new_y = y + iy
            new_x = x + ix
            if check(new_y, new_x):
                yield new_y, new_x # 무조건 한칸은 가능
            for multiple in range(1, 5):
                new_y = y + iy * multiple
                new_x = x + ix * multiple
                if (new_y, new_x) in remain_cards:
                    if check(new_y, new_x):
                        yield new_y, new_x
                    break
                    
                if not check(new_y, new_x):
                    new_y -= iy
                    new_x -= ix
                    yield new_y, new_x
                    break # 풀이 완료 후 추가 개선: break가 없으면 성능이 저하됨 (시간 초과까지는 X)
    
    @lru_cache(maxsize=None)
    def move(y1, x1, y2, x2, bitmask):
        remain_cards = set()
        for i in range(len(card_positions)):
            if not bitmask & (1 << i):
                remain_cards.add(card_index_to_yx[i])
        queue = deque()
        queue.append((0, y1, x1))
        visited = set()
        while queue:
            cost, y, x = queue.popleft()
            if (y,x) in visited:
                continue
            visited.add((y,x))
            
            if y == y2 and x== x2:
                return cost
            for new_y, new_x in get_tiles(y, x, remain_cards):
                if (new_y,new_x) in visited:
                    continue
                queue.append((cost+1, new_y, new_x))
        raise Exception("런타임 에러")
    
    answer = INF
    for arr in order(cards):
        y = r
        x = c
        bitmask = 0
        cost = 0
        for i, yx in enumerate(arr):
            cost += move(y, x, yx[0], yx[1], bitmask)
            y = yx[0]
            x = yx[1]
            cost += 1 # Enter
            if i % 2 == 1:
                bitmask |= 1 << card_positions[arr[i-1]]
                bitmask |= 1 << card_positions[arr[i]]
        answer = min(answer, cost)
            
    return answer
```


```
|   |   |
|---|---|
|테스트 1 〉|통과 (3.48ms, 9.33MB)|
|테스트 2 〉|통과 (4.30ms, 9.38MB)|
|테스트 3 〉|통과 (3.90ms, 9.3MB)|
|테스트 4 〉|통과 (3.81ms, 9.39MB)|
|테스트 5 〉|통과 (12.29ms, 9.43MB)|
|테스트 6 〉|통과 (15.30ms, 9.31MB)|
|테스트 7 〉|통과 (14.02ms, 9.18MB)|
|테스트 8 〉|통과 (13.82ms, 9.21MB)|
|테스트 9 〉|통과 (66.53ms, 9.36MB)|
|테스트 10 〉|통과 (76.80ms, 9.35MB)|
|테스트 11 〉|통과 (60.12ms, 9.3MB)|
|테스트 12 〉|통과 (73.38ms, 9.45MB)|
|테스트 13 〉|통과 (427.63ms, 9.54MB)|
|테스트 14 〉|통과 (470.67ms, 9.55MB)|
|테스트 15 〉|통과 (453.15ms, 9.5MB)|
|테스트 16 〉|통과 (534.76ms, 9.54MB)|
|테스트 17 〉|통과 (0.18ms, 9.46MB)|
|테스트 18 〉|통과 (0.36ms, 9.35MB)|
|테스트 19 〉|통과 (1.09ms, 9.3MB)|
|테스트 20 〉|통과 (0.71ms, 9.39MB)|
|테스트 21 〉|통과 (13.43ms, 9.36MB)|
|테스트 22 〉|통과 (404.27ms, 9.5MB)|
|테스트 23 〉|통과 (419.18ms, 9.54MB)|
|테스트 24 〉|통과 (14.07ms, 9.36MB)|
|테스트 25 〉|통과 (505.48ms, 9.55MB)|
|테스트 26 〉|통과 (12.70ms, 9.45MB)|
|테스트 27 〉|통과 (13.15ms, 9.45MB)|
|테스트 28 〉|통과 (7.45ms, 9.45MB)|
|테스트 29 〉|통과 (6.20ms, 9.15MB)|
|테스트 30 〉|통과 (3.55ms, 9.35MB)|
```